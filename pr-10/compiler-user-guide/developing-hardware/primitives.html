<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>User-defined primitives - Clash Compiler User Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clash Compiler User Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="user-defined-primitives"><a class="header" href="#user-defined-primitives">User-defined primitives</a></h1>
<p>There are times when you already have an existing piece of IP, or there are times where you need the HDL to have a specific shape so that the HDL synthesis tool can infer a specific component.
In these specific cases you can resort to defining your own HDL primitives. Actually, most of the primitives in Clash are specified in the same way as you will read about in this section.
There are perhaps 10 (at most) functions which are truly hard-coded into the Clash compiler.
You can take a look at the files in <a href="https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/vhdl">https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/vhdl</a> (or <a href="https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/verilog">https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/verilog</a> for the Verilog primitives or <a href="https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/systemverilog">https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/systemverilog</a> for the SystemVerilog primitives) if you want to know which functions are defined
as "regular" primitives.
The compiler looks for primitives in four locations:</p>
<ul>
<li>
<p>The official install location: e.g.</p>
<ul>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/common</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/commonverilog</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/systemverilog</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/verilog</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/vhdl</code></li>
</ul>
</li>
<li>
<p>Directories indicated by a <code>Clash.Annotations.Primitive.Primitive</code> annotation</p>
</li>
<li>
<p>The current directory (the location given by <code>pwd</code>)</p>
</li>
<li>
<p>The include directories specified on the command-line: <code>-i&lt;DIR&gt;</code></p>
</li>
</ul>
<p>Where redefined primitives in the current directory or include directories will overwrite those in the official install location.
For now, files containing primitive definitions must have a <code>.primitives.yaml</code> file-extension.</p>
<p>Clash differentiates between two types of primitives, <em>expression</em> primitives and <em>declaration</em> primitives, corresponding to whether the primitive is an HDL <em>expression</em> or an HDL <em>declaration</em>.
We will first explore <em>expression</em> primitives, using <code>Signed</code> multiplication (<code>*</code>) as an example.
The <code>Clash.Sized.Internal.Signed</code> module specifies multiplication as follows:</p>
<pre><code class="language-haskell">(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n
(S a) *# (S b) = fromInteger_INLINE (a * b)
{-# OPAQUE (*#) #-}
</code></pre>
<p>For which the VHDL /expression/ primitive is:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Sized.Internal.Signed.*#
  kind: Expression
  type: '(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n'
  template: resize(~ARG[1] * ~ARG[2], ~LIT[0])
</code></pre>
<p>The <code>name</code> of the primitive is the <em>fully qualified</em> name of the function you are creating the primitive for.
Because we are creating an <em>expression</em> primitive the kind must be set to <code>Expression</code>.
As the name suggest, it is a VHDL /template/, meaning that the compiler must fill in the holes heralded by the tilde (~).
Here:</p>
<ul>
<li><code>~ARG[1]</code> denotes the second argument given to the <code>(*#)</code> function, which     corresponds to the LHS of the (<code>*</code>) operator.</li>
<li><code>~ARG[2]</code> denotes the third argument given to the <code>(*#)</code> function, which     corresponds to the RHS of the (<code>*</code>) operator.</li>
<li><code>~LIT[0]</code> denotes the first argument given to the <code>(*#)</code> function, withthe extra condition that it must be a <code>LIT</code>eral.
If for some reason this first argument does not turn out to be a literal then the compiler will raise an error.
This first arguments corresponds to the <code>KnownNat n</code> class constraint.</li>
</ul>
<p>An extensive list with all of the template holes will be given the end of this section. What we immediately notice is that class constraints are counted as normal arguments in the primitive definition.
This is because these class constraints are actually represented by ordinary record types, with fields corresponding to the methods of the type class.
In the above case, <code>KnownNat</code> is actually just like a <code>newtype</code> wrapper for <code>Natural</code>.</p>
<p>The second kind of primitive that we will explore is the <em>declaration</em> primitive.
We will use <code>blockRam#</code> as an example, for which the Haskell/Clash code is:</p>
<pre><code class="language-haskell">{-# LANGUAGE BangPatterns #-}

module BlockRam where

import Clash.Explicit.Prelude
import Clash.Annotations.Primitive (hasBlackBox)
import Clash.Signal.Internal (Clock, Signal (..), (.&amp;&amp;.))
import Clash.Sized.Vector (Vec, toList)
import Clash.XException (defaultSeqX)

import qualified Data.Vector as V
import GHC.Stack (HasCallStack, withFrozenCallStack)

blockRam#
  :: ( KnownDomain dom
     , HasCallStack
     , NFDataX a )
  =&gt; Clock dom           -- ^ Clock to synchronize to
  -&gt; Enable dom          -- ^ Global enable
  -&gt; Vec n a             -- ^ Initial content of the BRAM, also
                         -- determines the size, @n@, of the BRAM.
                         --
                         -- __NB__: __MUST__ be a constant.
  -&gt; Signal dom Int      -- ^ Read address @r@
  -&gt; Signal dom Bool     -- ^ Write enable
  -&gt; Signal dom Int      -- ^ Write address @w@
  -&gt; Signal dom a        -- ^ Value to write (at address @w@)
  -&gt; Signal dom a        -- ^ Value of the BRAM at address @r@ from
                         -- the previous clock cycle
blockRam# (Clock _) gen content rd wen =
  go
    (V.fromList (toList content))
    (withFrozenCallStack (deepErrorX "blockRam: intial value undefined"))
    (fromEnable gen)
    rd
    (fromEnable gen .&amp;&amp;. wen)
 where
  go !ram o ret@(~(re :- res)) rt@(~(r :- rs)) et@(~(e :- en)) wt@(~(w :- wr)) dt@(~(d :- din)) =
    let ram' = d `defaultSeqX` upd ram e (fromEnum w) d
        o'   = if re then ram V.! r else o
    in  o `seqX` o :- (ret `seq` rt `seq` et `seq` wt `seq` dt `seq` go ram' o' res rs en wr din)

  upd ram we waddr d = case maybeIsX we of
    Nothing -&gt; case maybeIsX waddr of
      Nothing -&gt; V.map (const (seq waddr d)) ram
      Just wa -&gt; ram V.// [(wa,d)]
    Just True -&gt; case maybeIsX waddr of
      Nothing -&gt; V.map (const (seq waddr d)) ram
      Just wa -&gt; ram V.// [(wa,d)]
    _ -&gt; ram
{-# OPAQUE blockRam# #-}
{-# ANN blockRam# hasBlackBox #-}
</code></pre>
<p>And for which the <em>declaration</em> primitive is:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Explicit.BlockRam.blockRam#
  kind: Declaration
  type: |-
    blockRam#
      :: ( KnownDomain dom        ARG[0]
         , HasCallStack  --       ARG[1]
         , NFDataX a )   --       ARG[2]
      =&gt; Clock dom       -- clk,  ARG[3]
      -&gt; Enable dom      -- en,   ARG[4]
      -&gt; Vec n a         -- init, ARG[5]
      -&gt; Signal dom Int  -- rd,   ARG[6]
      -&gt; Signal dom Bool -- wren, ARG[7]
      -&gt; Signal dom Int  -- wr,   ARG[8]
      -&gt; Signal dom a    -- din,  ARG[9]
      -&gt; Signal dom a
  template: |-
    -- blockRam begin
    ~GENSYM[~RESULT_blockRam][1] : block
      signal ~GENSYM[~RESULT_RAM][2] : ~TYP[5] := ~CONST[5];
      signal ~GENSYM[rd][4]  : integer range 0 to ~LENGTH[~TYP[5]] - 1;
      signal ~GENSYM[wr][5]  : integer range 0 to ~LENGTH[~TYP[5]] - 1;
    begin
      ~SYM[4] &lt;= to_integer(~ARG[6])
      -- pragma translate_off
                    mod ~LENGTH[~TYP[5]]
      -- pragma translate_on
                    ;
      ~SYM[5] &lt;= to_integer(~ARG[8])
      -- pragma translate_off
                    mod ~LENGTH[~TYP[5]]
      -- pragma translate_on
                    ;
    ~IF ~VIVADO ~THEN
      ~SYM[6] : process(~ARG[3])
      begin
        if ~IF~ACTIVEEDGE[Rising][0]~THENrising_edge~ELSEfalling_edge~FI(~ARG[3]) then
          if ~ARG[7] ~IF ~ISACTIVEENABLE[4] ~THEN and ~ARG[4] ~ELSE ~FI then
            ~SYM[2](~SYM[5]) &lt;= ~TOBV[~ARG[9]][~TYP[9]];
          end if;
          ~RESULT &lt;= fromSLV(~SYM[2](~SYM[4]))
          -- pragma translate_off
          after 1 ps
          -- pragma translate_on
          ;
        end if;
      end process; ~ELSE
      ~SYM[6] : process(~ARG[3])
      begin
        if ~IF~ACTIVEEDGE[Rising][0]~THENrising_edge~ELSEfalling_edge~FI(~ARG[3]) then
          if ~ARG[7] ~IF ~ISACTIVEENABLE[4] ~THEN and ~ARG[4] ~ELSE ~FI then
            ~SYM[2](~SYM[5]) &lt;= ~ARG[9];
          end if;
          ~RESULT &lt;= ~SYM[2](~SYM[4])
          -- pragma translate_off
          after 1 ps
          -- pragma translate_on
          ;
        end if;
      end process; ~FI
    end block;
    --end blockRam
</code></pre>
<p>Again, the <code>name</code> of the primitive is the fully qualified name of the function you are creating the primitive for.
Because we are creating a <em>declaration</em> primitive the <em>kind</em> must be set to <code>Declaration</code>.
Instead of discussing what the individual template holes mean in the above context, we will instead just give a general listing of the available template holes:</p>
<ul>
<li><code>~RESULT</code>: Signal to which the result of a primitive must be assigned
to. NB: Only used in a <em>declaration</em> primitive.</li>
<li><code>~ARG[N]</code>: <code>(N+1)</code>'th argument to the function.</li>
<li><code>~CONST[N]</code>: <code>(N+1)</code>'th argument to the function. Like <code>~ARG</code>, but Clash will try to reduce this to a literal, even if it would otherwise consider it too expensive.
And if Clash fails to reduce this argument to a literal it will produce an error.</li>
<li><code>~LIT[N]</code>: <code>(N+1)</code>'th argument to the function. Like <code>~CONST~</code> but values are   rendered as a bare literals, without any size or type annotations.
This only works for numeric types, and not for BitVector.</li>
<li><code>~TYP[N]</code>: VHDL type of the <code>(N+1)</code>'th argument.</li>
<li><code>~TYPO</code>: VHDL type of the result.</li>
<li><code>~TYPM[N]</code>: VHDL type_name_ of the <code>(N+1)</code>'th argument; used in <em>type qualification</em>.</li>
<li><code>~TYPMO</code>: VHDL type_name_ of the result; used in <em>type qualification</em>.</li>
<li><code>~ERROR[N]</code>: Error value for the VHDL type of the <code>(N+1)</code>'th argument.</li>
<li><code>~ERRORO</code>: Error value for the VHDL type of the result.</li>
<li><code>~GENSYM[&lt;NAME&gt;][N]</code>: Create a unique name, trying to stay as close to
the given <code>&lt;NAME&gt;</code> as possible. This unique symbol can be referred to in
other places using <code>~SYM[N]</code>.</li>
<li><code>~SYM[N]</code>: a reference to the unique symbol created by <code>~GENSYM[&lt;NAME&gt;][N]</code>.</li>
<li><code>~SIGD[&lt;HOLE&gt;][N]</code>: Create a signal declaration, using <code>&lt;HOLE&gt;</code> as the name
of the signal, and the type of the <code>(N+1)</code>'th argument.</li>
<li><code>~SIGDO[&lt;HOLE&gt;]</code>: Create a signal declaration, using <code>&lt;HOLE&gt;</code> as the name
of the signal, and the type of the result.</li>
<li><code>~TYPEL[&lt;HOLE&gt;]</code>: The element type of the vector type represented by <code>&lt;HOLE&gt;</code>.
The content of <code>&lt;HOLE&gt;</code> must either be: <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~COMPNAME</code>: The name of the component in which the primitive is instantiated.</li>
<li><code>~LENGTH[&lt;HOLE&gt;]</code>: The vector length of the type represented by <code>&lt;HOLE&gt;</code>.</li>
<li><code>~DEPTH[&lt;HOLE&gt;]</code>: The tree depth of the type represented by <code>&lt;HOLE&gt;</code>.
The content of <code>&lt;HOLE&gt;</code> must either be: <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~SIZE[&lt;HOLE&gt;]</code>: The number of bits needed to encode the type represented by <code>&lt;HOLE&gt;</code>.
The content of <code>&lt;HOLE&gt;</code> must either be: <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~IF &lt;CONDITION&gt; ~THEN &lt;THEN&gt; ~ELSE &lt;ELSE&gt; ~FI</code>: renders the <code>&lt;ELSE&gt;</code>
part when <code>&lt;CONDITION&gt;</code> evaluates to <em>0</em>, and renders the <code>&lt;THEN&gt;</code> in all
other cases.
Valid <code>&lt;CONDITION&gt;</code>s are <code>~LENGTH[&lt;HOLE&gt;]</code>, <code>~SIZE[&lt;HOLE&gt;]</code>, <code>~CMPLE[&lt;HOLE1&gt;][&lt;HOLE2&gt;]</code>, <code>~DEPTH[&lt;HOLE&gt;]</code>, <code>~VIVADO</code>, <code>~IW64</code>, <code>~ISLIT[N]</code>, <code>~ISVAR[N]</code>, <code>~ISACTIVEENABLE[N]</code>, <code>~ISSYNC[N]</code>, and <code>~AND[&lt;HOLE1&gt;,&lt;HOLE2&gt;,..]</code>.</li>
<li><code>~VIVADO</code>: <em>1</em> when Clash compiler is invoked with the <code>-fclash-xilinx</code> or
<code>-fclash-vivado</code> flag.
To be used with in an <code>~IF .. ~THEN .. ~ELSE .. ~FI</code> statement.</li>
<li><code>~CMPLE[&lt;HOLE1&gt;][&lt;HOLE2&gt;]</code>: <em>1</em> when <code>&lt;HOLE1&gt; &lt;= &lt;HOLE2&gt;</code>, otherwise <em>0</em></li>
<li><code>~IW64</code>: <em>1</em> when <code>Int</code>/<code>Word</code>/<code>Integer</code> types are represented with 64 bits in HDL.
<em>0</em> when they're represented by 32 bits.</li>
<li><code>~TOBV[&lt;HOLE&gt;][&lt;TYPE&gt;]</code>: create conversion code that so that the expression in <code>&lt;HOLE&gt;</code> is converted to a bit vector (<code>std_logic_vector</code>).
The <code>&lt;TYPE&gt;</code> hole indicates the type of the expression and must be either <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~FROMBV[&lt;HOLE&gt;][&lt;TYPE&gt;]</code>: create conversion code that so that the expression in <code>&lt;HOLE&gt;</code>, which has a bit vector (<code>std_logic_vector</code>) type, is converted to type indicated by <code>&lt;TYPE&gt;</code>.
The <code>&lt;TYPE&gt;</code> hole must be either <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~INCLUDENAME[N]</code>: the generated name of the <code>N</code>'th included component.</li>
<li><code>~FILE[&lt;HOLE&gt;]</code>: The argument mentioned in <code>&lt;HOLE&gt;</code> is a file which must be copied to the location of the generated HDL.</li>
<li><code>~GENERATE</code>: Verilog: create a <em>generate</em> statement, except when already in a <em>generate</em> context.</li>
<li><code>~ENDGENERATE</code>: Verilog: create an <em>endgenerate</em> statement, except when already in a <em>generate</em> context.</li>
<li><code>~ISLIT[N]</code>: Is the <code>(N+1)</code>'th argument to the function a literal.</li>
<li><code>~ISVAR[N]</code>: Is the <code>(N+1)</code>'th argument to the function explicitly not a literal.</li>
<li><code>~ISSCALAR[N]</code>: Is the <code>(N+1)</code>'th argument to the function a scalar.
Note that this means different things for different HDLs.
In (System)Verilog only <code>Bit</code> and <code>Bool</code> are considered scalar.
In VHDL, in addition to those two, enumeration types and integers are considered scalar.</li>
<li><code>~TAG[N]</code>: Name of given domain.
Errors when called on an argument which is not a 'KnownDomain', 'Reset', or 'Clock'.</li>
<li><code>~PERIOD[N]</code>: Clock period of given domain.
Errors when called on an argument which is not a 'Clock', 'Reset', 'KnownDomain' or 'KnownConf'.</li>
<li><code>~ISACTIVEENABLE[N]</code>: Is the <code>(N+1)</code>'th argument a an Enable line <strong>not</strong> set to a constant True.
Can be used instead of deprecated (and removed) template tag</li>
<li><code>~ISSYNC[N]</code>: Does synthesis domain at the <code>(N+1)</code>'th argument have synchronous resets.
Errors when called on an argument which is not a 'Reset', 'Clock', 'Enable', 'KnownDomain' or 'KnownConf'.</li>
<li><code>~ISINITDEFINED[N]</code>: Does synthesis domain at the <code>(N+1)</code>'th argument have defined initial values.
Errors when called on an argument which is not a 'Clock', 'Reset', 'Enable', 'KnownDomain' or 'KnownConf'.</li>
<li><code>~ACTIVEEDGE[edge][N]</code>: Does synthesis domain at the <code>(N+1)</code>'th argument respond to
<em>edge</em>.
<em>edge</em> must be one of 'Falling' or 'Rising'.
Errors when called on an argument which is not a 'Clock', 'Reset', 'Enable', 'KnownDomain' or 'KnownConf'.</li>
<li><code>~AND[&lt;HOLE1&gt;,&lt;HOLE2&gt;,..]</code>: Logically <em>and</em> the conditions in the <code>&lt;HOLE&gt;</code>'s</li>
<li><code>~VAR[&lt;NAME&gt;][N]</code>: Like <code>~ARG[N]</code> but binds the argument to a variable named NAME.
The <code>&lt;NAME&gt;</code> can be left blank, then Clash will come up with a (unique) name.</li>
<li><code>~VARS[N]</code>: VHDL: Return the variables at the <code>(N+1)</code>'th argument.</li>
<li><code>~NAME[N]</code>: Render the <code>(N+1)</code>'th string literal argument as an identifier instead of a string literal.
Fails when the <code>(N+1)</code>'th argument is not a string literal.</li>
<li><code>~DEVNULL[&lt;HOLE&gt;]</code>: Render all dependencies of <code>&lt;HOLE&gt;</code>, but disregard direct output.</li>
<li><code>~REPEAT[&lt;HOLE&gt;][N]</code>: Repeat literal value of <code>&lt;HOLE&gt;</code> a total of <code>N</code> times.</li>
<li><code>~TEMPLATE[&lt;HOLE1&gt;][&lt;HOLE2&gt;]</code>: Render a file <code>&lt;HOLE1&gt;</code> with contents <code>&lt;HOLE2&gt;</code>.</li>
</ul>
<p>Some final remarks to end this section: HDL primitives are there to instruct the Clash compiler to use the given HDL template, instead of trying to do normal synthesis.
As a consequence you can use constructs inside the Haskell definitions that are normally not synthesizable by the Clash compiler.
However, VHDL primitives do not give us <em>co-simulation</em>: where you would be able to simulate VHDL and Haskell in a <em>single</em> environment.
If you still want to simulate your design in Haskell, you will have to describe, in a cycle- and bit-accurate way, the behavior of that (potentially complex) IP you are trying to include in your design.</p>
<h2 id="verilog-examples"><a class="header" href="#verilog-examples">Verilog examples</a></h2>
<p>For those who are interested, the equivalent Verilog primitives are:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Sized.Internal.Signed.*#
  kind: Expression
  type: '(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n'
  template: ~ARG[1] * ~ARG[2]
</code></pre>
<p>and</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Explicit.BlockRam.blockRam#
  kind: Declaration
  outputUsage: NonBlocking
  type: |-
    blockRam#
      :: ( KnownDomain dom        ARG[0]
         , HasCallStack  --       ARG[1]
         , NFDataX a )   --       ARG[2]
      =&gt; Clock dom       -- clk,  ARG[3]
      =&gt; Enable dom      -- en,   ARG[4]
      -&gt; Vec n a         -- init, ARG[5]
      -&gt; Signal dom Int  -- rd,   ARG[6]
      -&gt; Signal dom Bool -- wren, ARG[7]
      -&gt; Signal dom Int  -- wr,   ARG[8]
      -&gt; Signal dom a    -- din,  ARG[9]
      -&gt; Signal dom a
  template: |-
    // blockRam begin
    reg ~TYPO ~GENSYM[~RESULT_RAM][1] [0:~LENGTH[~TYP[5]]-1];
    reg ~TYP[5] ~GENSYM[ram_init][3];
    integer ~GENSYM[i][4];
    initial begin
      ~SYM[3] = ~CONST[5];
      for (~SYM[4]=0; ~SYM[4] &lt; ~LENGTH[~TYP[5]]; ~SYM[4] = ~SYM[4] + 1) begin
        ~SYM[1][~LENGTH[~TYP[5]]-1-~SYM[4]] = ~SYM[3][~SYM[4]*~SIZE[~TYPO]+:~SIZE[~TYPO]];
      end
    end
    ~IF ~ISACTIVEENABLE[4] ~THEN
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~GENSYM[~RESULT_blockRam][5]~IF ~VIVADO ~THEN
      if (~ARG[4]) begin
        if (~ARG[7]) begin
          ~SYM[1][~ARG[8]] &lt;= ~ARG[9];
        end
        ~RESULT &lt;= ~SYM[1][~ARG[6]];
      end~ELSE
      if (~ARG[7] &amp; ~ARG[4]) begin
        ~SYM[1][~ARG[8]] &lt;= ~ARG[9];
      end
      if (~ARG[4]) begin
        ~RESULT &lt;= ~SYM[1][~ARG[6]];
      end~FI
    end~ELSE
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~SYM[5]
      if (~ARG[7]) begin
        ~SYM[1][~ARG[8]] &lt;= ~ARG[9];
      end
      ~RESULT &lt;= ~SYM[1][~ARG[6]];
    end~FI
    // blockRam end
</code></pre>
<h2 id="systemverilog-examples"><a class="header" href="#systemverilog-examples">SystemVerilog examples</a></h2>
<p>And the equivalent SystemVerilog primitives are:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Sized.Internal.Signed.*#
  kind: Expression
  type: '(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n'
  template: ~ARG[1] * ~ARG[2]
</code></pre>
<p>and</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Explicit.BlockRam.blockRam#
  kind: Declaration
  type: |-
    blockRam#
      :: ( KnownDomain dom        ARG[0]
         , HasCallStack  --       ARG[1]
         , NFDataX a )   --       ARG[2]
      =&gt; Clock dom       -- clk,  ARG[3]
      -&gt; Enable dom      -- en,   ARG[4]
      -&gt; Vec n a         -- init, ARG[5]
      -&gt; Signal dom Int  -- rd,   ARG[6]
      -&gt; Signal dom Bool -- wren, ARG[7]
      -&gt; Signal dom Int  -- wr,   ARG[8]
      -&gt; Signal dom a    -- din,  ARG[9]
      -&gt; Signal dom a
  template: |-
    // blockRam begin
    ~SIGD[~GENSYM[RAM][1]][5];
    logic [~SIZE[~TYP[9]]-1:0] ~GENSYM[~RESULT_q][2];
    initial begin
      ~SYM[1] = ~CONST[5];
    end~IF ~ISACTIVEENABLE[4] ~THEN
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~GENSYM[~COMPNAME_blockRam][3]~IF ~VIVADO ~THEN
      if (~ARG[4]) begin
        if (~ARG[7]) begin
          ~SYM[1][~ARG[8]] &lt;= ~TOBV[~ARG[9]][~TYP[9]];
        end
        ~SYM[2] &lt;= ~SYM[1][~ARG[6]];
      end~ELSE
      if (~ARG[7] &amp; ~ARG[4]) begin
        ~SYM[1][~ARG[8]] &lt;= ~TOBV[~ARG[9]][~TYP[9]];
      end
      if (~ARG[4]) begin
        ~SYM[2] &lt;= ~SYM[1][~ARG[6]];
      end~FI
    end~ELSE
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~SYM[3]
      if (~ARG[7]) begin
        ~SYM[1][~ARG[8]] &lt;= ~TOBV[~ARG[9]][~TYP[9]];
      end
      ~SYM[2] &lt;= ~SYM[1][~ARG[6]];
    end~FI
    assign ~RESULT = ~FROMBV[~SYM[2]][~TYP[9]];
    // blockRam end
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../developing-hardware/flags.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../hacking-on-clash/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../developing-hardware/flags.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../hacking-on-clash/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
