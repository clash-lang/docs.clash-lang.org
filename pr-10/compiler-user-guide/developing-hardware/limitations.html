<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Limitations of the compiler - Clash Compiler User Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clash Compiler User Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="limitations-of-the-compiler"><a class="header" href="#limitations-of-the-compiler">Limitations of the compiler</a></h1>
<p>Here is a list of Haskell features for which the Clash compiler has only <em>limited</em> support (for now):</p>
<ul>
<li>
<p><strong>Recursively defined functions</strong></p>
<p>At first hand, it seems rather bad that a compiler for a functional language cannot synthesize recursively defined functions to circuits.
However, when viewing your functions as a <em>structural</em> specification of a circuit, this <em>feature</em> of the Clash compiler makes sense.
Also, only certain types of recursion are considered non-synthesizable; recursively defined values are for example synthesizable: they are (often) synthesized to feedback loops.</p>
<p>Let us distinguish between three variants of recursion:</p>
<ul>
<li>
<p><strong>Dynamic data-dependent recursion</strong></p>
<p>As demonstrated in this definition of a function that calculates the n'th Fibbonacci number:</p>
<pre><code class="language-haskell">fibR 0 = 0
fibR 1 = 1
fibR n = fibR (n-1) + fibR (n-2)
</code></pre>
<p>To get the first 10 numbers, we do the following:</p>
<pre><code>&gt;&gt;&gt; import qualified Data.List as L
&gt;&gt;&gt; L.map fibR [0..9]
[0,1,1,2,3,5,8,13,21,34]
</code></pre>
<p>The <code>fibR</code> function is not synthesizable by the Clash compiler, because, when we take a <em>structural</em> view, <code>fibR</code> describes an infinitely deep structure.</p>
<p>In principle, descriptions like the above could be synthesized to a circuit, but it would have to be a <em>sequential</em> circuit.
Where the most general synthesis would then require a stack.
Such a synthesis approach is also known as <em>behavioral</em> synthesis, something which the Clash compiler simply does not do.
One reason that Clash does not do this is because it does not fit the paradigm that only functions working on values of type <code>Signal</code> result in sequential circuits, and all other (non higher-order) functions result in combinational circuits.
This paradigm gives the designer the most straightforward mapping from the original Haskell description to generated circuit, and thus the greatest control over the eventual size of the circuit and longest propagation delay.</p>
</li>
<li>
<p><strong>Value-recursion</strong></p>
<p>As demonstrated in this definition of a function that calculates the n'th Fibbonaci number on the n'th clock cycle:</p>
<pre><code class="language-haskell">fibS :: SystemClockResetEnable =&gt; Signal System (Unsigned 64)
fibS = r
    where r = register 0 r + register 0 (register 1 r)
</code></pre>
<p>To get the first 10 numbers, we do the following:</p>
<pre><code>&gt;&gt;&gt; sampleN @System 11 fibS
[0,0,1,1,2,3,5,8,13,21,34]
</code></pre>
<p>Unlike the <code>fibR</code> function, the above <code>fibS</code> function <em>is</em> synthesizable by the Clash compiler.
Where the recursively defined (non-function) value <em>r</em> is synthesized to a feedback loop containing three registers and one adder.</p>
<p>Note that not all recursively defined values result in a feedback loop.
An example that uses recursively defined values which does not result in a feedback loop is the following function that performs one iteration of bubble sort:</p>
<pre><code class="language-haskell">sortV xs = map fst sorted :&lt; (snd (last sorted))
  where
    lefts  = head xs :&gt; map snd (init sorted)
    rights = tail xs
    sorted = zipWith compareAndSwap (lazyV lefts) rights

compareAndSwap a b = if a &lt; b then (a,b) else (b,a)
</code></pre>
<p>Where we can clearly see that <code>lefts</code> and <code>sorted</code> are defined in terms of each other.
Also the above <code>sortV</code> function <em>is</em> synthesizable.</p>
</li>
<li>
<p><strong>Static/Structure-dependent recursion</strong></p>
<p>Static, or, structure-dependent recursion is a rather <em>vague</em> concept.
What we mean by this concept are recursive definitions where a user can sensibly imagine that the recursive definition can be completely unfolded (all recursion is eliminated) at compile-time in a finite amount of time.</p>
<p>Such definitions would e.g. be:</p>
<pre><code class="language-haskell">mapV :: (a -&gt; b) -&gt; Vec n a -&gt; Vec n b
mapV _ Nil         = Nil
mapV f (Cons x xs) = Cons (f x) (mapV f xs)

topEntity :: Vec 4 Int -&gt; Vec 4 Int
topEntity = mapV (+1)
</code></pre>
<p>Where one can imagine that a compiler can unroll the definition of <code>mapV</code> four times, knowing that the <code>topEntity</code> function applies <code>mapV</code> to a <code>Vec</code> of length 4.
Sadly, the compile-time evaluation mechanisms in the Clash compiler are very poor, and a user-defined function such as the <code>mapV</code> function defined above, is <em>currently</em> not synthesizable.
We <em>do</em> plan to add support for this in the future.
In the mean time, this poor support for user-defined recursive functions is amortized by the fact that the Clash compiler has built-in support for the higher-order functions defined in <code>Clash.Sized.Vector</code>.
Most regular design patterns often encountered in circuit design are captured by the higher-order functions in <code>Clash.Sized.Vector</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Recursive datatypes</strong></p>
<p>The Clash compiler needs to be able to determine a bit-size for any value that will be represented in the eventual circuit.
More specifically, we need to know the maximum number of bits needed to represent a value.
While this is trivial for values of the elementary types, sum types, and product types, putting a fixed upper bound on recursive types is not (always) feasible.
This means that the ubiquitous list type is unsupported!
The only recursive types that are currently supported by the Clash compiler is the <code>Vec</code>tor and <code>RTree</code> types, for which the compiler has hard-coded knowledge.</p>
<p>For "easy" <code>Vec</code>tor literals you should use Template Haskell splices and the <code>listToVecTH</code> <em>meta</em>-function.</p>
</li>
<li>
<p><strong>GADTs</strong></p>
<p>Clash has experimental support for GADTs.
Similar to recursive types, Clash cannot determine bit-sizes of GADTs.
Notable exceptions to this rule are <code>Vec</code> and <code>RTree</code>.
You can still use your own GADTs, as long as they can be removed through static analysis.
For example, the following case will be optimized away and is therefore fine to use:</p>
<pre><code class="language-haskell">x =
  case resetKind @System of
    SAsynchronous -&gt; 'a'
    SSynchronous -&gt; 'b'
</code></pre>
</li>
<li>
<p><strong>Floating point types</strong></p>
<p>There is no support for the <code>Float</code> and <code>Double</code> types, if you need numbers with a <em>fractional</em> part you can use the <code>Fixed</code> point type.</p>
<p>As to why there is no support for these floating point types:</p>
<ol>
<li>
<p>In order to achieve reasonable operating frequencies, arithmetic circuits for floating point data types must be pipelined.</p>
</li>
<li>
<p>Haskell's primitive arithmetic operators on floating point data types, such as <code>plusFloat#</code></p>
<pre><code class="language-haskell">plusFloat# :: Float# -&gt; Float# -&gt; Float#
</code></pre>
<p>which underlie <code>Float</code>'s <code>Num</code> instance, must be implemented as purely combinational circuits according to their type.
Remember, sequential circuits operate on values of type <code>Signal dom a</code>.</p>
</li>
</ol>
<p>Although it is possible to implement purely combinational (not pipelined) arithmetic circuits for floating point data types, the circuit would be unreasonable slow.
So, without synthesis possibilities for the basic arithmetic operations, there is no point in supporting the floating point data types.</p>
</li>
<li>
<p><strong>Haskell primitive types</strong></p>
<p>Only the following primitive Haskell types are supported:</p>
<ul>
<li><code>Integer</code></li>
<li><code>Int</code></li>
<li><code>Int8</code></li>
<li><code>Int16</code></li>
<li><code>Int32</code></li>
<li><code>Int64</code> (not available when compiling with <code>-fclash-intwidth=32</code> on a 64-bit machine)</li>
<li><code>Word</code></li>
<li><code>Word8</code></li>
<li><code>Word16</code></li>
<li><code>Word32</code></li>
<li><code>Word64</code> (not available when compiling with <code>-fclash-intwidth=32</code> on a 64-bit machine)</li>
<li><code>Char</code></li>
</ul>
<p>There are several aspects of which you should take note:</p>
<ul>
<li>
<p><code>Int</code> and <code>Word</code> are represented by the same number of bits as is native for the architecture of the computer on which the Clash compiler is executed.
This means that if you are working on a 64-bit machine, <code>Int</code> and <code>Word</code> will be 64-bit.
This might be problematic when you are working in a team, and one designer has a 32-bit machine, and the other has a 64-bit machine.
In general, you should be avoiding 'Int' in such cases, but as a band-aid solution, you can force the Clash compiler to use a specific bit-width for <code>Int</code> and <code>Word</code> using the <code>-fclash-intwidth=N</code> flag, where <em>N</em> must either be <em>32</em> or <em>64</em>.</p>
</li>
<li>
<p>When you use the <code>-fclash-intwidth=32</code> flag on a <em>64-bit</em> machine, the 'Word64' and 'Int64' types <em>cannot</em> be translated. This restriction does <em>not</em> apply to the other three combinations of <code>-fclash-intwidth</code> flag and machine type.</p>
</li>
<li>
<p>The translation of 'Integer' is not meaning-preserving.
'Integer' in Haskell is an arbitrary precision integer, something that cannot be represented in a statically known number of bits.
In the Clash compiler, we chose to represent 'Integer' by the same number of bits as we do for <code>Int</code> and <code>Word</code>.
As you have read in a previous bullet point, this number of bits is either 32 or 64, depending on the architecture of the machine the Clash compiler is running on, or the setting of the <code>-fclash-intwidth</code> flag.</p>
<p>Consequently, you should use <code>Integer</code> with due diligence; be especially careful when using <code>fromIntegral</code> as it does a conversion via 'Integer'.
For example:</p>
<pre><code class="language-haskell">signedToUnsigned :: Signed 128 -&gt; Unsigned 128
signedToUnsigned = fromIntegral
</code></pre>
<p>can either lose the top 64 or 96 bits depending on whether <code>Integer</code> is represented by 64 or 32 bits.
Instead, when doing such conversions, you should use <code>bitCoerce</code>:</p>
<pre><code class="language-haskell">signedToUnsigned :: Signed 128 -&gt; Unsigned 128
signedToUnsigned = bitCoerce
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Side-effects: <code>IO</code>, <code>ST</code>, etc.</strong></p>
<p>There is no support for side-effecting computations such as those in the <code>IO</code> or <code>ST</code> monad.
There is also no support for Haskell's <a href="http://www.haskell.org/haskellwiki/Foreign_Function_Interface">FFI</a>.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../developing-hardware/primitives.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../hacking-on-clash/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../developing-hardware/primitives.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../hacking-on-clash/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
