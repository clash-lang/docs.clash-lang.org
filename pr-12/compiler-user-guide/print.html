<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clash Compiler User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clash Compiler User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="clash-compiler-language-user-guide"><a class="header" href="#clash-compiler-language-user-guide">Clash Compiler Language User Guide</a></h1>
<p>Welcome to the Clash Compiler User Guide, the official documentation of the <a href="https://clash-lang.org">Clash Compiler</a>.
Clash is an open-source functional hardware description language (HDL) that borrows syntax and semantics from the <a href="https://www.haskell.org">Haskell</a> programming language.
To learn more, we suggest reading the <a href="general/index.html">introduction to Clash</a>.</p>
<p>The table of contents in the sidebar (which can be opened in the menu on the top left) allows easy access to different pages in the documentation.
You can also use the search function in the top-left corner.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>The Clash Compiler and Clash Language User Guide are open-source efforts developed by QBayLogic B.V., volunteers and students.
The Clash Team always appreciates feedback and contributions to the project to help improve the development experience.</p>
<p>If you don't understand something, or think something is missing or incorrect in the documentation you can open an issue or pull request in the <a href="https://github.com/clash-lang/docs.clash-lang.org">GitHub repository</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-clash"><a class="header" href="#installing-clash">Installing Clash</a></h1>
<p>Check out <a href="https://clash-lang.org/install">clash-lang.org/install</a> to install the latest stable release of Clash, or to setup a Clash project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-clash"><a class="header" href="#introduction-to-clash">Introduction to Clash</a></h1>
<h2 id="functional-hardware"><a class="header" href="#functional-hardware">Functional Hardware</a></h2>
<p><a href="https://clash-lang.org">Clash</a> is an open-source functional hardware description language (HDL) that closely mirrors the syntax and semantics of the <a href="https://www.haskell.org">Haskell</a> programming language.
It is used for creating hardware designs, typically for running on <em>field programmable gate arrays</em> (FPGAs) or <em>application-specific integrated circuits</em> (ASICs).</p>
<p>Clash is both a compiler, and a set of libraries for circuit design, that transform high level Haskell descriptions of synchronous, sequential logic into low-level <a href="https://en.wikipedia.org/wiki/VHDL">VHDL</a>, <a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a>, or <a href="https://en.wikipedia.org/wiki/SystemVerilog">SystemVerilog</a>.
It provides a unique approach to design of sequential circuits, with a high amount of abstraction power that blurs the line between strictly behavioral and structural synthesis approaches.</p>
<p>Clash aims to modernize the hardware development experience, making it easier to quickly and correctly develop complex circuit designs.
This is achieved by making Clash:</p>
<p><strong>Expressive</strong></p>
<p>Clash uses the Haskell type system to its full potential — including modern extensions and techniques — to bring a high level of type safety and expressiveness to hardware design.</p>
<p>This expressive typing makes it easier to develop safe, maintainable hardware.
Combinational and sequential logic is separated by type, and global safety invariants such as separating incompatible clock domains are enforced in the type system.</p>
<p><strong>Intuitive</strong></p>
<p>Clash makes it easy to express circuit designs in an intuitive manner, allowing high level structural components to be connected easily in designs.
Moreover, unlike most "high level synthesis" tools, this extends to precise control over register placement and pipelining.</p>
<p><strong>Interactive</strong></p>
<p>Unlike traditional HDL tools, Clash has a fully interactive <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">read-eval-print loop</a> (REPL), allowing circuits to be interactively designed and tested.</p>
<p><strong>Performant</strong></p>
<p>Clash reuses parts of the <a href="https://ghc.haskell.org">Glasgow Haskell Compiler</a> to provide fast simulation of circuits for development and testing.</p>
<p><strong>Efficient</strong></p>
<p>Clash uses a "whole program synthesis" approach in order to view the entire circuit at once, and optimizes this design before translating to a specific target.
This allows meaningful optimizations to be performed on the entire design.</p>
<p><strong>Extensible</strong></p>
<p>Additional primitives and black boxes can be added to Clash in the language of your choice, allowing you to use your own vendor or IP library within projects.</p>
<p>Clash allows seamless interoperability with libraries written in Haskell, including <code>mtl</code>, <code>lens</code> and <code>hedgehog</code>.
This makes it even easier to quickly prototype complex designs.</p>
<h2 id="intended-audience"><a class="header" href="#intended-audience">Intended Audience</a></h2>
<p>Clash is ideal for developers from different backgrounds, although the main intended audiences are</p>
<p><strong>Hardware Engineers</strong></p>
<p>You are a hardware engineer, used to using tools like <a href="https://en.wikipedia.org/wiki/VHDL">VHDL</a> and <a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a> to implement circuit designs.
Clash offers the familiar mixed simulation/synthesis capabilities of these tools, while providing a language with powerful abstractions.</p>
<p><strong>Haskell Programmers</strong></p>
<p>You are a <a href="https://www.haskell.org">Haskell</a> programmer, looking to start developing hardware.
Clash offers the ability to start prototyping and simulating designs in a familiar environment — lowering the learning curve significantly.</p>
<h2 id="maturity-and-support"><a class="header" href="#maturity-and-support">Maturity and Support</a></h2>
<p>Clash is a continually evolving tool, having been actively developed since 2009.
With the release of Clash 1.0 there has been an increased focus on maintaining API stability between releases, meaning circuit designs written in Clash should continue to work between minor releases.
Today, the Clash Compiler is actively developed by QBayLogic B.V., volunteers and students.</p>
<p>Several companies and enthusiasts are already using Clash to develop circuit designs, ranging from small designs on hobbyist boards to larger designs on modern FPGA and ASIC architectures.</p>
<p>While care is taken to thoroughly test the Clash compiler, some bugs may exist.
We encourage users to file issues, or contribute pull requests on our <a href="https://github.com/clash-lang/clash-compiler">GitHub repository</a>.</p>
<h2 id="meta-information-web-sites-mailing-lists-etc"><a class="header" href="#meta-information-web-sites-mailing-lists-etc">Meta-information: Web Sites, Mailing Lists, etc.</a></h2>
<p><strong>Mailing list</strong>: for updates and questions join the mailing list <a href="mailto:general/clash-language+subscribe@googlegroups.com">clash-language+subscribe@googlegroups.com</a> or read the <a href="https://groups.google.com/d/forum/clash-language">forum</a></p>
<p><strong>Slack</strong>: Invite yourself at <a href="https://fpchat-invite.herokuapp.com/">fpchat-invite.herokuapp.com</a>.
To join #clash, click on "Channels" and search for "clash".</p>
<p><strong>IRC</strong>: <a href="https://webchat.freenode.net/#clash-lang">freenode#clash-lang</a></p>
<h2 id="clash-version-numbering-policy"><a class="header" href="#clash-version-numbering-policy">Clash Version Numbering Policy</a></h2>
<p>Clash follows the <a href="https://pvp.haskell.org">Haskell PVP Specification</a> for its version numbers, for all packages.
The main libraries that make up the Clash compiler maintain the same version numbers, making it easy to identify which versions are compatible.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>Due to the Clash's tight integration with GHC, updates to the GHC version that Clash uses result in changes to the Clash version.
As GHC's internals change frequently, even for minor bumps, it cannot be guaranteed that these changes will not result in Clash changes.</p>
</div>
<p>It is recommended (but not required) that downstream Clash packages and published Clash code also follow the PVP specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h1>
<p>Up to date release notes of the clash compiler can be found on the <a href="https://github.com/clash-lang/clash-compiler/releases">Github releases page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="basic-questions"><a class="header" href="#basic-questions">Basic Questions</a></h2>
<ul>
<li>
<p><strong>Q</strong>: How do I install Clash?</p>
<p><strong>A</strong>: Check out the <code>installing</code> page in the <em>Getting Started</em> section of the manual.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Is the name "Clash", "CLaSH", or "CλaSH"?</p>
<p><strong>A</strong>: It's <strong>Clash</strong>.</p>
<p>In its research stages Clash was called "CλaSH", an acronym for the <strong>C</strong>AES <strong>La</strong>nguage for <strong>S</strong>ynchronous <strong>H</strong>ardware.
CAES is a group of the Faculty of Electrical Engineering, Mathematics and Computer Science at the University of Twente.
Clash was originally developed by Christaan Baaij and supervisor Jan Kuper.
The stylization "CλaSH" is an homage to <a href="https://haskell.org">Haskell</a>, whose official logo has long been the venerable Greek <em>lambda</em> character.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Is Clash a "high level synthesis" tool?</p>
<p><strong>A</strong>: While clash provides a high level language features, hardware descriptions written in Clash are not decoupled from clock-level timing.
Clash does therefore not offer what is generally understood as "high level synthesis".
Compared to the big three hardware description languages, <em>VHDL</em>, <em>Verilog</em>, and <em>SystemVerilog</em>, Clash arguably <em>is</em> high-level.
It offers many of the powerful abstractions that modern software programming languages offer.
In fact, it inherits many of the software industry's bleeding-edge features by virtue of basing its implementation on Haskell.</p>
</li>
</ul>
<h2 id="clash-support"><a class="header" href="#clash-support">Clash Support</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Is Clash production ready?</p>
<p><strong>A</strong>: Clash is constantly evolving, and since the 1.0 release there is a focus on maintaining API backwards compatibility.
Clash is used successfully in real-world scenarios, and <a href="https://qbaylogic.com/clash-support.html">QBayLogic Clash support</a> can help with education and implementation of Clash projects.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Will Clash work with my EDA tools?</p>
<p><strong>A</strong>: In general, Clash should work well with Xilinx and Intel FPAGs and their EDA tools — as development typically focuses on these vendors.
Clash has also been successfully used on Microsemi (formerly Actel) SmartFusion 2 and Lattice Semiconductor iCE40 FPGAs, and some basic IP for these exist.</p>
<p>For most toolchains, the default primitives supplied by Clash should work with minimal effort.
If not, it is possible to call your vendor's library manually, or use a tool like <a href="http://clifford.at/yosys">Yosys</a> to do mapping.
It is also possible to consult <a href="https://qbaylogic.com/clash-support.html">QBayLogic Clash support</a> for more assistance.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Does Clash support <a href="http://clifford.at/icestorm">Project IceStorm</a>?</p>
<p><strong>A</strong>: The Verilog backend for Clash emits Verilog 2001, which is supported by <a href="http://clifford.at/yosys">Yosys</a>.
This means it can be placed and packed with <em>arachne-pnr</em> and <em>icestorm</em>.
Additionally, Clash has some support for the Lattice Semiconductor iCE40 FPGA.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Can Clash be used for ASIC designs, as well as FPGA designs?</p>
<p>Clash can be used for ASIC designs, however the RTL produced by Clash may not be immediately suitable as it is largely platform agnostic.
While this is not a problem for FPGAs, it can make developing ASICs more complicated as many ASIC vendors have different proprietary tool flows, with limited information available about their workings.</p>
<p>If you are using Clash to develop for ASIC, and need assistance with getting your toolchain to work, you can contact <a href="https://qbaylogic.com/clash-support.html">QBayLogic Clash support</a> for assistance.</p>
</li>
</ul>
<h2 id="clash-and-haskell"><a class="header" href="#clash-and-haskell">Clash and Haskell</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Is Clash its own programming language, or is it Haskell?</p>
<p><strong>A</strong>: Clash is a programming language in its own right, complete with its own executable and standard library.
Clash is also related to the Haskell programming language, and may be thought of as a dialect of Haskell for developing hardware.
While the surface syntax and typing rules are the same, the semantics change as code progresses through the compilation pipeline.</p>
<p>Due to the shared behavior in the early stages of the compiler, components from GHC (the most common Haskell compiler) are reused in the Clash compiler.
This is how Clash achieves such high interoperability with existing Haskell projects.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Clash has better inference for type level natural numbers than GHC.
How is this possible?</p>
<p><strong>A</strong>: Clash's enhanced type checking functionality is due to the use of GHC compiler plugins, which can be used in any Haskell project.
To enable these plugins, pass the following compiler flags to GHC:</p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise       #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Extra.Solver    #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
</code></pre>
<p>These plugins come from the <code>ghc-typelits-natnormalise</code>, <code>ghc-typelits-extra</code>, and <code>ghc-typelits-knownnat</code> packages respectively, which are all available from Hackage and Stackage.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Do I need to know Haskell in order to use Clash?</p>
<p><strong>A</strong>: As Clash is deeply integrated with Haskell, it is recommended that users have some familiarity with Haskell, or functional programming in general.
Clash uses some advanced features of Haskell, and real-world designs will often want to leverage the existing Haskell ecosystem.</p>
<p>For developers who are particularly familiar with either Haskell or hardware design, Clash should be relatively intuitive to use.
Additionally, obvious mistakes with designs will be identified and reported due to the strong type system identifying mistakes at compile-time.</p>
</li>
</ul>
<h2 id="clash-and-other-hdls"><a class="header" href="#clash-and-other-hdls">Clash and other HDLs</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Do I need to know existing RTL/HDL languages in order to use Clash?</p>
<p><strong>A</strong>: Clash currently outputs VHDL, Verilog, and SystemVerilog.
While it's not necessary to understand these descriptions, you will need to some understanding of vendor tools to actually deploy it.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: What's the difference between Clash and Lava?</p>
<p><strong>A</strong>: Lava dialects (including the modern variant <a href="https://github.com/mn416/blarney">Blarney</a>) are all embedded domain specific languages (EDSLs) inside Haskell.
On top of that they use a so-called <em>deep</em> embedding to be able to transform a circuit description into a netlist (to subsequently output that as a VHDL/Verilog file).
Clash on the other hand uses "standard" compiler techniques to create a netlist from the Haskell abstract syntax tree (AST).
This "standard" compiler technique enables the following features not available in (Haskell-based) EDSLs:</p>
<blockquote>
<ol>
<li>Clash allows the use of normal Haskell operations such as (==) on both the meta-level (how the program is structured/generated), and the object-level (the functionality of the program).</li>
<li>Clash allows the use of regular Haskell syntax to model the concept of 'choice' at the object-level (the functionality of the program): if-expressions, guards, case, etc.</li>
<li>Clash allows programmers to use native Haskell pattern matching.</li>
</ol>
</blockquote>
<p>Basically, with Clash you can use regular Haskell to describe the behavior of the circuit, most importantly all of it's choice-constructs (case-expressions, guards, etc.).
With an EDSL you are "limited" by the constructs of the DSL, making your circuit descriptions look less like regular Haskell functions.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: What's the difference between Clash and Chisel/Spinal/Migen/Hardcaml?</p>
<p><strong>A</strong>: The biggest difference between these toolchains and Clash is that Clash exists as a Haskell derivative, with a full synthesizing compiler to RTL — while Chisel/Spinal/Migen/Hardcaml exists as an embedding of hardware semantics inside Scala/Scala/Python/OCaml.
Aside from the "host language" differences, this means that Chisel/Spinal/Migen/Hardcaml are conceptually closer to something like Lava/Blarney than to Clash.
So within these languages you can only use the host language constructs to structure and compose the constructs of the EDSL, and you can't use host language constructs to describe the behavior of the circuit; i.e. you cannot use the host language's regular if-expression to model the concept of choice, but you have to use e.g. Chisel's <em>when</em>-function.</p>
<p>Aside from the above, there is also a varying degree of <em>native</em> simulation and interactivity.
In Clash you can evaluate/simulate any (sub-)component in the interactive interpreter for an immediate and localized design feedback loop.
The only EDSLs that have a similar interactive interpreter for fast design feedback are the older variants of Lava.
They used a so-called dual-embedding, where the EDSL primitives also contained a normal Haskell function which described their behavior, and so the composition of these primitives could be evaluated as a regular Haskell function.</p>
<p>The other EDSLs all offer simulation, but there is a higher latency to get from a design to a simulation of a design, and they are not as interactive.
Blarney emits Verilog, and you can then use a Verilog simulator to simulate the Blarney design.
Spinal also emits Verilog, but it then uses Verilator to compile it to an object-file which is loaded back into Scala, allowing you to interact with your Spinal design from within Scala.
Chisel is also not interpreted directly, instead, a Chisel description is "lowered" to FIRRTL where that FIRRTL description is then executed inside Scala by the FIRRTL interpreter.
Migen works similarly to Chisel as far as the approach to simulation goes, although perhaps more direct: it directly interprets its own deep embedding data structure (its <em>IR</em>) to enable native simulation.</p>
<p>All of this influences the style in which you write circuits and the creative process by which you come to a solution; the effects of this on the quality of results (QoR) and development time are, however, both hard to qualify and hard to quantify.
That is, although all of these languages, both the EDSLs and Clash, enable full control over the QoR (i.e. you can get as many registers and as much logic as you intended), the way in which you get there can vary from problem domain to problem domain and person to person.
If you have enough time, we encourage to try several of them and see which style is the most natural fit for you; if you're limited on time, we of course recommend that you just go with Clash ;-)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<div class="literalinclude" language="text">
<p>Copyright (c) 2012-2016, University of Twente,
2016-2019, Myrtle Software Ltd,
2017-2019, QBayLogic B.V., Google Inc.
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clash-as-a-language"><a class="header" href="#clash-as-a-language">Clash as a Language</a></h1>
<p>As Clash reuses parts of the GHC compiler for its frontend, the syntax and semantics should be familiar to Haskell programmers.
For people unfamiliar with Haskell, there are many resources to learn the language, such as</p>
<ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell">The Haskell Wikibook</a></li>
</ul>
<p>Clash does make some use of more advanced features of GHC Haskell, which are exposed by GHC as language extensions.
The extensions used by Clash are</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/binary_literals.html">BinaryLiterals</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/constraint_kind.html">ConstraintKinds</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/data_kinds.html">DataKinds</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/derive_any_class.html">DeriveAnyClass</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/generics.html#extension-DeriveGeneric">DeriveGeneric</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/deriving_extra.html#extension-DeriveLift">DeriveLift</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/deriving_strategies.html">DerivingStrategies</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/explicit_forall.html">ExplicitForAll</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/explicit_namespaces.html">ExplicitNamespaces</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/flexible_contexts.html">FlexibleContexts</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/instances.html#extension-FlexibleInstances">FlexibleInstances</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/kind_signatures.html">KindSignatures</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/magic_hash.html">MagicHash</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/let_generalisation.html?highlight=monolocalbinds#extension-MonoLocalBinds">MonoLocalBinds</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/numeric_underscores.html">NumericUnderscores</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/rebindable_syntax.html">NoImplicitPrelude</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/poly_kinds.html?#the-kind-type">NoStarIsType</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/strict.html#strict-by-default-data-types">NoStrictData</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/strict.html#strict-by-default-pattern-bindings">NoStrict</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/template_haskell.html#template-haskell-quasi-quotation">QuasiQuotes</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/scoped_type_variables.html">ScopedTypeVariables</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/template_haskell.html#extension-TemplateHaskellQuotes">TemplateHaskellQuotes</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/template_haskell.html">TemplateHaskell</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_applications.html">TypeApplications</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_families.html">TypeFamilies</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_operators.html">TypeOperators</a></li>
</ul>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>Since GHC 8.6, the <code>StarIsType</code> extension is defined.
This extension is explicitly turned off by Clash, meaning <code>Data.Kind.Type</code> must be used to refer to Haskell types.</p>
</div>
<p>Clash also enables some GHC plugins by default which improve the type inference for type level numbers.
The plugins enabled by default are</p>
<ul>
<li><a href="https://hackage.haskell.org/package/ghc-typelits-extra">ghc-typelits-extra</a></li>
<li><a href="https://hackage.haskell.org/package/ghc-typelits-knownnat">ghc-typelits-knownnat</a></li>
<li><a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">ghc-typelits-natnormalise</a></li>
</ul>
<p>Users are free to control the language extensions and GHC options with the normal <code>OPTIONS_GHC</code> and <code>LANGUAGE</code> pragmas in source files.
For more information, see the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/">GHC User's Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clash-prelude"><a class="header" href="#clash-prelude">Clash Prelude</a></h1>
<h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<p>The Clash prelude includes many different numeric types, which are used to safely define other types/functions.
These include, but may not be limited to</p>
<ul>
<li>
<p>Type level natural numbers (<code>Nat</code>), which allow numbers to be used in types.
Conceptually, this is similar to <em>const generics</em> in <em>C++</em>.</p>
<p>It is possible to have term level values which refer to a type level number.
This is called <code>SNat n</code> (for <em>singleton natural number</em>).
These are defined up to 1024 with the prefix "d" (e.g. <code>d256</code>).</p>
</li>
<li>
<p><code>Unsigned n</code> and <code>Signed n</code> numbers with an arbitrary width (given as a type level natural number).
These allow fixed-width arithmetic to be used on arbitrary numbers.</p>
</li>
<li>
<p><code>Index n</code> provides natural numbers up to an arbitrary value (given as a type level natural number).
These allow indexing into fixed width structures like <code>Vec n a</code>.</p>
</li>
</ul>
<p>Another commonly used type is <code>BitVector n</code>.
This provides a fixed size vector of <code>Bit</code> values which can be indexed, and used to perform <em>unsigned integer arithmetic</em>.
Any type that can be marshaled to/from a <code>BitVector n</code> implements the <code>BitPack</code> class, which defines the conversion.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>It is also possible to derive instances of <code>BitPack</code> using <code>Generic</code>, by writing <code>deriving (Generic, BitPack)</code> in the type definition.
This automatically determines how to do the conversion at compile-time.</p>
</div>
<p>More generally, there is a <code>Vec n a</code> type which allows collections of arbitrary values to be used.
These vectors are tagged with their length, to prevent out of bounds access at compile-time.</p>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>The <code>Vec n a</code> type exports pattern synonyms for inserting at the left and right of a vector.
The types of the <code>Cons</code> constructor and <code>(:&gt;)</code> pattern are slightly different, and may behave differently in practice.</p>
<p>The <code>Cons</code> constructor has a more general type, allowing it to be used in some cases where the pattern cannot be used.
However, this additional power comes at the cost of type inference.
It is recommended that users use the <code>(:&gt;)</code> pattern by default, and only use <code>Cons</code> when necessary.</p>
</div>
<h2 id="synthesis-domains"><a class="header" href="#synthesis-domains">Synthesis Domains</a></h2>
<p>Synchronous circuits have a synthesis domain, which determines the behavior of things which can affect signals in the domain.
Domains consist of</p>
<ul>
<li>a name, which uniquely refers to the domain</li>
<li>the clock period in ps</li>
<li>the active edge of the clock</li>
<li>whether resets are synchronous (edge-sensitive) or not</li>
<li>whether the initial (power up) behavior is defined</li>
<li>whether resets are high or low polarity</li>
</ul>
<p>The prelude provides some common domains, namely <code>XilinxSystem</code> and <code>IntelSystem</code> for the standard configurations of each vendor.
There is also a generic domain, <code>System</code>, which can be used for vendor-agnostic purposes (e.g., writing a generic test bench).
It is possible to define new synthesis domains for custom hardware using the <code>createDomain</code> function, which also defines the necessary instances for domains.</p>
<p>A value in a synchronous circuit is wrapped in the <code>Signal dom a</code> type, which specifies the synthesis domain and the type of value.
Any function which needs access to a domain can use the constraint <code>KnownDomain</code> to extract configuration.</p>
<p>The default API exposed by the prelude is implicit with regards to clocks, reset lines and enable lines, as these can be determined at compile time.
However, if they are needed the <code>Clash.Explicit</code> module contains explicit versions of the API which expose these directly in function arguments.
It is also possible to use functions like <code>exposeClockResetEnable</code> to turn an implicitly defined function to an explicitly defined function.</p>
<h2 id="state-machines"><a class="header" href="#state-machines">State Machines</a></h2>
<p>The Clash prelude contains combinators for two classical finite state machines which can be used to define synchronous circuits.
The first of these is <code>mealy</code>, which encodes a <a href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy machine</a>.
This is a machine specified by</p>
<ul>
<li>A transition function of type <code>state -&gt; input -&gt; (state, output)</code></li>
<li>An initial state</li>
<li>An input signal which can change at each cycle</li>
</ul>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>The Mealy machine is similar to the <code>State</code> monad, which Haskell programmers may already be familiar with.
Practically speaking, the only difference is that this machine also has an input signal which is changed externally to the definition of the machine.</p>
</div>
<p>It is also possible to define a <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore machine</a> using the <code>moore</code> function in the Clash prelude.
This differs from the Mealy machine by providing output based on the previous state (as opposed to the newly calculated state), and is specified by</p>
<ul>
<li>A transition function of type <code>state -&gt; input -&gt; state</code></li>
<li>An output function of type <code>state -&gt; output</code></li>
<li>An initial state</li>
<li>An input signal which can change at each cycle</li>
</ul>
<p>Sometimes, there may be multiple inputs/outputs needed for a machine.
As machines only input and output a single signal, there is a way to combine and separate multiple signals.
The <code>Bundle</code> class specifies how to convert between some type which is a signal of a product, and some type which is a product of signals, e.g.</p>
<pre><code class="language-haskell">bundle   :: (Signal dom a, Signal dom b) -&gt; Signal dom (a, b)
unbundle :: Signal dom (a, b) -&gt; (Signal dom a, Signal dom b)
</code></pre>
<p>There are combinators which can automatically perform this bundling and unbundling for you as required, called <code>mealyB</code> and <code>mooreB</code>.
The <code>Bundle</code> class is already defined for many types, including tuples (up to 62 elements), <code>Maybe a</code>, <code>Either a b</code> and <code>Vec n a</code>.</p>
<h2 id="ram-and-rom"><a class="header" href="#ram-and-rom">RAM and ROM</a></h2>
<p>The Clash prelude provides the ability to work with synchronous and asynchronous ROM, asynchronous RAM and synchronous Block RAM.
The simplest of these are ROMs, which only allow indexing into a <code>Vec n a</code> of elements.
ROM is defined using the functions in <code>Clash.Prelude.ROM</code>.</p>
<p>RAM is more complex, as it allows both reading and writing.
The function to define a RAM takes in a signal for the address to read, and a signal for an optional address to update (bundled with the new value).
At each cycle it outputs the value of the memory address read in the previous cycle.
Asynchronous RAM is defined in <code>Clash.Prelude.RAM</code>.</p>
<p>An FPGA may include a block RAM, which is a larger memory structure and more suitable for some applications.
Block RAM also has a synchronous read port, allowing memory access to be synchronized to a clock.
Block RAM is used the same way as async RAM, allowing the two to be compared quickly.
Block RAM is defined in <code>Clash.Prelude.BlockRam</code>.</p>
<h2 id="undefined-values"><a class="header" href="#undefined-values">Undefined Values</a></h2>
<p>When working with hardware designs, there are times when undefined values may be encountered in simulation.
Clash provides a custom exception type, <code>XException</code>, for cases when an undefined value is encountered.
There are also many utility functions for working with exceptions, such as</p>
<ul>
<li><code>errorX</code>, which throws an <code>XException</code></li>
<li><code>isX</code> and <code>hasX</code>, which check for <code>XExceptions</code> when evaluating</li>
<li><code>maybeIsX</code> and <code>maybeHasX</code>, which discard information about exceptions</li>
</ul>
<p>There are also implementations of typical classes in Haskell which have been changed to work with undefined values.
Currently these are</p>
<ul>
<li><code>ShowX</code>, which works like the <code>Show</code> class in Haskell.
When an undefined value is encountered an "X" is printed.
<code>Show</code> can still be used, but will throw an exception if an undefined value is encountered.</li>
<li><code>NFDataX</code>, which works like the <code>NFData</code> class in the <code>deepseq</code> library.
This allows evaluating values to normal form in code when <code>XException</code> may be present.
<code>NFData</code> can still be used, but will bubble up exceptions if <code>XException</code> is encountered.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clash-compiler-flags"><a class="header" href="#clash-compiler-flags">Clash Compiler Flags</a></h1>
<p><code>--vhdl</code><br />
Use the VHDL backend for code generation.
This currently emits VHDL 1993 source which can be consumed by other tools.</p>
<p><code>--verilog</code><br />
Use the Verilog backend for code generation.
This currently emits Verilog 2001 source which can be consumed by other tools.</p>
<p><code>--systemverilog</code><br />
Use the SystemVerilog backend for code generation.
This currently emits SystemVerilog 2012 source which can be consumed by other tools.</p>
<p><code>-fclash-debug</code><br />
Set the debugging mode for the compiler, exposing additional output.
The available options are</p>
<ul>
<li><code>DebugNone</code> to show no debug messages</li>
<li><code>DebugSilent</code> to test invariants and error if any are violated.
This is implicitly enabled by any debug flag.</li>
<li><code>DebugFinal</code> to show expressions after they have been completely normalized</li>
<li><code>DebugCount</code> to count how often each transformation is applied</li>
<li><code>DebugName</code> to show the names of transformations as they are applied</li>
<li><code>DebugTry</code> to show names of tried and applied transformations</li>
<li><code>DebugApplied</code> to show sub-expressions after they are rewritten</li>
<li><code>DebugAll</code> to show all sub-expressions when a rewrite is attempted</li>
</ul>
<p><strong>Default:</strong> <code>DebugNone</code></p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>This flag exists for backwards compatibility.
It is now possible to set debugging flags individually with
<span class="title-ref"><code>-fclash-debug-invariants</code></span>,
<span class="title-ref"><code>-fclash-debug-info</code></span> and
<span class="title-ref"><code>-fclash-debug-count-transformations</code></span>.</p>
</div>
<p><code>-fclash-debug-invariants</code><br />
Check invariants while debugging and print warnings/errors which may be useful, such as alerting when unexpected changes occur or when a transformation introduces free variables / shadowing.</p>
<p><code>-fclash-debug-info</code><br />
Specify the information to show about individual transformations while debugging.
From least to most information, these are</p>
<ul>
<li><code>None</code> to show no information</li>
<li><code>FinalTerm</code> to show the final result of normalization</li>
<li><code>AppliedName</code> to show the names of applied transformations</li>
<li><code>AppliedTerm</code> to show the result of applied transformations</li>
<li><code>TryName</code> to show the names of attempted transformations, as well as the result of any transformations which are applied</li>
<li><code>TryTerm</code> to show the names and results of all transformations attempted whether they were applied or not</li>
</ul>
<p><strong>Default:</strong> <code>None</code></p>
<p><code>-fclash-debug-count-transformations</code><br />
Count the transformations that are applied and print a summary at the end of the normalization phase.</p>
<p><code>-fclash-debug-history[=FILENAME]</code><br />
Saves all applied rewrites into <code>FILENAME</code>, for later analysis with the clash-term tool.
When no filename is given it defaults to <code>history.dat</code>.</p>
<p><code>-fclash-debug-transformations</code><br />
List the transformations that are to be debugged.
This is given as a comma-separated list of transformations, e.g.</p>
<pre><code class="language-bash">clash -fclash-debug-transformations inlineNonRep,topLet,appProp
</code></pre>
<p><strong>Default:</strong> <code>[]</code></p>
<p><code>-fclash-debug-transformations-from=N</code><br />
Only print debug output from applied transformation <code>N</code> and onwards.</p>
<pre><code class="language-bash">clash -fclash-debug-transformations-from=21570
</code></pre>
<p><strong>Default:</strong> <code>0</code></p>
<p><code>-fclash-debug-transformations-limit=N</code><br />
Only print debug output for <code>N</code> applied transformations.</p>
<pre><code class="language-bash">clash -fclash-debug-transformations-limit=12
</code></pre>
<p><strong>Default:</strong> <code>MAX_INT</code></p>
<p><code>-fclash-hdldir</code><br />
Specify the directory that generated HDL is written into.
For example</p>
<pre><code class="language-bash">clash -fclash-hdldir build/hdl
</code></pre>
<p>will create a directory <code>build/hdl</code></p>
<p><strong>Default:</strong> Either <code>vhdl</code>, <code>verilog</code>, or <code>systemverilog</code> depending on the synthesis target.</p>
<p><code>-fclash-hdlsyn</code><br />
Specify the HDL synthesis tool which will be used.
Available options are <code>Vivado</code>, <code>Quartus</code> and <code>Other</code>, but some synonyms for these exist (<code>Xilinx</code> and <code>ISE</code> are synonyms for <code>Vivado</code>, <code>Altera</code> and <code>Intel</code> are synonyms for <code>Quartus</code>).</p>
<p><strong>Default:</strong> <code>Other</code></p>
<p><code>-fclash-no-cache</code><br />
Don't reuse previously generated output from Clash, instead generating HDL from a clean state.
While this leads to longer builds, it can be useful in development.</p>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>Previously this flag was called <code>-fclash-nocache</code>, however this is now deprecated.</p>
</div>
<p><strong>Default:</strong> Cache generated HDL</p>
<p><code>-fclash-no-check-inaccessible-idirs</code><br />
Check that all include directories (containing primitives) exist when running Clash.
If any directory does not exist, an error is thrown.</p>
<p><strong>Default:</strong> Check directories</p>
<p><code>-fclash-clear</code><br />
Remove HDL directories before writing to them (if cache can't be used).
By default, Clash will only write to non-empty directories if it can prove all files in it are generated by a previous run.
This option applies to directories of the various top entities, i.e., the subdirectories made in the directory passed in with <code>-fclash-hdldir</code>.</p>
<p><strong>Default:</strong> Clean before build</p>
<p><code>-fclash-no-prim-warn</code><br />
Disable warnings for primitives that are annotated with <code>warnAlways</code>.
This means warnings from annotations like</p>
<pre><code class="language-haskell">{-# ANN f (warnAlways "This primitive is dangerous") #-}
</code></pre>
<p>will not be shown when compiling.</p>
<p><strong>Default:</strong> Show warnings</p>
<p><code>-fclash-spec-limit</code><br />
Change the number of times a function can undergo specialization.</p>
<p><strong>Default:</strong> 20</p>
<p><code>-fclash-inline-limit</code><br />
Change the number of times a function <code>f</code> can undergo inlining inside some other function <code>g</code>.
This prevents the size of <code>g</code> growing dramatically.</p>
<p><strong>Default:</strong> 20</p>
<p><code>-fclash-inline-function-limit</code><br />
Set the threshold for function size.
Below this threshold a function is always inlined (if it is not recursive).</p>
<p><strong>Default:</strong> 15</p>
<p><code>-fclash-inline-constant-limit</code><br />
Set the threshold for constant size.
Below this threshold constants are always inlined.
A value of 0 inlines all constants.</p>
<p><strong>Default:</strong> 0</p>
<p><code>-fclash-evaluator-fuel-limit</code><br />
Set the threshold for unfolding potentially non-terminating bindings in the evaluator.
A value of 0 only unfolds terminating bindings.</p>
<p><strong>Default:</strong> 20</p>
<p><code>-fclash-intwidth</code><br />
Set the bit width for the <code>Int/Word/Integer</code> types in the generated HDL.
Clash simulation is not affected, and neither are <code>BitPack</code> instances.
The only allowed values are 32 or 64.</p>
<p><strong>Default:</strong> Machine word size (<code>WORD_SIZE_IN_BITS</code>)</p>
<p><code>-fclash-error-extra</code><br />
Print additional information with compiler errors if it as available.
If there is extra information and this flag is not enabled, a message will be printed suggesting this flag.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-float-support</code><br />
Enable support for floating point numbers.
If this is disabled, Clash will not attempt to convert Float and Double values for hardware.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-component-prefix</code><br />
Prefix the names of generated HDl components with a string.
For example a component <code>foo</code> would be called <code>xcorp_foo</code> if run with</p>
<pre><code class="language-bash">clash -fclash-component-prefix "xcorp"
</code></pre>
<p><strong>Default:</strong> ""</p>
<p><code>-fclash-old-inline-strategy</code><br />
The new inlining strategy for Clash inlines all functions which are not marked with <code>NOINLINE</code> or a synthesize attribute.
The old inlining strategy differed, attempting only to inline functions which were deemed "cheap".
The old inlining strategy may be quicker in practice for some circuits.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-no-escaped-identifiers</code><br />
Disable extended identifiers, as used in some HDLs like VHDL to allow more flexibility with names.
Clash will only generate basic identifiers if this is used.</p>
<p><strong>Default:</strong> Escaped identifiers are allowed</p>
<p><code>-fclash-lower-case-basic-identifiers</code><br />
Clash will only generate lower case basic identifiers if this is used.
This affects places where the various HDLs only allow basic identifiers to be used, most notably module and file names.</p>
<p><strong>Default:</strong> Disabled</p>
<p><code>-fclash-compile-ultra</code><br />
Aggressively run the normalizer, potentially gaining much better runtime performance at the expense of compile time.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-force-undefined{,0,1}</code><br />
Set the value to use when an undefined value is inserted into generated HDL.
This flag can be suffixed with either 0 or 1 to force use of that bit, or left without a suffix to use a HDL-specific default (e.g. <code>x</code> in Verilog).</p>
<p><strong>Default:</strong> Disabled</p>
<p><code>-fclash-aggressive-x-optimization</code><br />
Remove all undefined branches from case expressions, replacing them with another defined value in the expression.
If only one branch is defined, the case expression is elided completely.
If no branches are defined the entire expression is replaced with a call to <code>errorX</code>.</p>
<p><strong>Implies:</strong> <code>-fclash-aggressive-x-optimization-blackboxes</code></p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-aggressive-x-optimization-blackboxes</code><br />
Allow blackboxes to detect undefined values and change their behavior accordingly.
For example, if <code>register</code> is used in combination with an undefined reset value, it will leave out the reset logic entirely.
This flag is enabled when using <code>-fclash-aggressive-x-optimization</code>.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-edalize</code><br />
Generate metadata for use with <a href="https://github.com/olofk/edalize">Edalize</a>.
This generates edam.py files in all top entities with the configuration for building that entity.
Users still need to edit this file to specify the EDA tool to use, and if necessary the device to target (for Quartus, Vivado etc.).</p>
<p><strong>Default:</strong> False</p>
<p><code>-main-is</code><br />
When using one of <code>--vhdl</code>, <code>--verilog</code>, or <code>--systemverilog</code>, this flag refers to the synthesis target.
For example, running Clash with <code>clash My.Module -main-is top --vhdl</code> would synthesize <code>My.Module.top</code>.</p>
<p><code>-fclash-timescale-precision</code><br />
Sets the second part of Verilog's <code>timescale 100fs/100fs</code>.
E.g., setting this flag to <code>1fs</code> would make Clash generate Verilog files with <code>timescale 100fs/1fs</code> as their header.</p>
<p><strong>Default:</strong> <code>100fs</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hacking-on-the-clash-compiler"><a class="header" href="#hacking-on-the-clash-compiler">Hacking on the Clash Compiler</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Hacking on Clash requires more dependencies than simply running Clash.
The test suite requires having a tool available to synthesize any backend being tested.
This means you need:</p>
<ul>
<li><a href="https://github.com/ghdl/ghdl">ghdl</a> installed to test <em>VHDL</em></li>
<li><a href="https://github.com/steveicarus/iverilog">iverilog</a> installed to test <em>Verilog</em></li>
<li><a href="https://fpgasoftware.intel.com/?product=modelsim_ae#tabs-2">ModelSim</a> installed to test <em>SystemVerilog</em></li>
<li><a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a> and <a href="https://github.com/Z3Prover/z3">Z3</a> installed to test <em>Verilog</em> and <em>SystemVerilog</em></li>
</ul>
<h2 id="get-clash-from-source"><a class="header" href="#get-clash-from-source">Get Clash from source</a></h2>
<p>Get the source code using <a href="https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F">Git</a> and enter the cloned directory:</p>
<pre><code class="language-bash">git clone git@github.com:clash-lang/clash-compiler.git

# Alternatively, if you haven't setup SSH keys with GitHub:
# git clone https://github.com/clash-lang/clash-compiler.git

cd clash-compiler
</code></pre>
<p>To check out a released version, use:</p>
<pre><code class="language-bash">git checkout v1.2.3
</code></pre>
<p>To checkout a release <em>branch</em> use:</p>
<pre><code class="language-bash">git checkout 1.2
</code></pre>
<p>Note that release branches might contain non-released patches.</p>
<h3 id="cabal"><a class="header" href="#cabal">Cabal</a></h3>
<p>To use Cabal you need both Cabal and GHC installed on your system.
For Linux and MacOS users we recommend using <a href="https://www.haskell.org/ghcup/">ghcup</a>.
Windows users are recommended to use the <a href="https://www.haskell.org/platform/windows.html">Haskell Platform</a>.</p>
<p>To run <span class="title-ref">clash</span> use:</p>
<pre><code class="language-bash">cabal v2-run --write-ghc-environment-files=always -- clash
</code></pre>
<p>If this fails, make sure you've got an up-to-date package index:</p>
<pre><code class="language-bash">cabal update
</code></pre>
<h3 id="stack"><a class="header" href="#stack">Stack</a></h3>
<p><a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/">Install Stack</a> and run:</p>
<pre><code class="language-bash">stack run -- clash
</code></pre>
<h3 id="nix"><a class="header" href="#nix">Nix</a></h3>
<p>Or <a href="https://nixos.org/nix/download.html">use Nix</a> to get a shell with the <code>clash</code> and <code>clashi</code> binaries on your PATH:</p>
<pre><code class="language-bash">nix-shell
</code></pre>
<h2 id="subprojects"><a class="header" href="#subprojects">Subprojects</a></h2>
<p>The Clash compiler consists of different cabal libraries, which together provide a complete compiler.
Primarily, this consists of</p>
<p><code>clash-ghc</code></p>
<blockquote>
<p>The frontend of the compiler, using parts of the GHC frontend.
This provides the ability to load modules, translate GHC Core to Clash Core, and implements the <code>clash</code> and <code>clashi</code> executables.</p>
<p>A lot of the code in this library is separated by the version of GHC it works with.
For example, <code>src-bin-9.0</code> is specific to GHC 9.0.x.</p>
</blockquote>
<p><code>clash-lib</code></p>
<blockquote>
<p>The backend of the compiler, exposed as a library.
This is the largest library in the project, and includes the various ASTs (e.g. Core, Netlist), normalization, code generation, and primitives / black boxes.</p>
</blockquote>
<p><code>clash-prelude</code></p>
<blockquote>
<p>The standard library for Clash as a language.
This includes anything that is used to develop hardware in Clash, such as Signals, Clocks and combinators for common forms of state machine.</p>
<p>The <code>clash-prelude</code> library also re-exports parts of the Haskell <code>base</code> library, allowing circuit designs to reuse common functions and definitions.</p>
</blockquote>
<p>The repository also contains other libraries.
These either provide additional functionality which is not required, or are not yet production-ready.
These are</p>
<p><code>clash-cosim</code></p>
<blockquote>
<p>Co-simulation for Clash, allowing Verilog to be run inline as though it were a normal Haskell function.
This provides a QuasiQuoter for use in Haskell.</p>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>This library is very experimental, and is not guaranteed to work with the most recent development version of Clash.</p>
</div>
</blockquote>
<p><code>clash-term</code></p>
<blockquote>
<p>A development tool for analyzing how the normalizer in <code>clash-lib</code> affects the core of a particular design.
It allows the result of each different optimizer pass to be seen for debugging purposes.</p>
</blockquote>
<p><code>clash-lib-hedgehog</code></p>
<blockquote>
<p>Hedgehog Generators for <code>clash-lib</code>.</p>
</blockquote>
<p><code>clash-prelude-hedgehog</code></p>
<blockquote>
<p>Hedgehog Generators for <code>clash-prelude</code>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
