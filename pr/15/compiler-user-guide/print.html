<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clash Compiler User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clash Compiler User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="clash-compiler-language-user-guide"><a class="header" href="#clash-compiler-language-user-guide">Clash Compiler Language User Guide</a></h1>
<p>Welcome to the Clash Compiler User Guide, the official documentation of the <a href="https://clash-lang.org">Clash Compiler</a>.
Clash is an open-source functional hardware description language (HDL) that borrows syntax and semantics from the <a href="https://www.haskell.org">Haskell</a> programming language.
To learn more, we suggest reading the <a href="general/index.html">introduction to Clash</a>.</p>
<p>The table of contents in the sidebar (which can be opened in the menu on the top left) allows easy access to different pages in the documentation.
You can also use the search function in the top-left corner.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>The Clash Compiler and Clash Language User Guide are open-source efforts developed by QBayLogic B.V., volunteers and students.
The Clash Team always appreciates feedback and contributions to the project to help improve the development experience.</p>
<p>If you don't understand something, or think something is missing or incorrect in the documentation you can open an issue or pull request in the <a href="https://github.com/clash-lang/docs.clash-lang.org">GitHub repository</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-clash"><a class="header" href="#installing-clash">Installing Clash</a></h1>
<p>Check out <a href="https://clash-lang.org/install">clash-lang.org/install</a> to install the latest stable release of Clash, or to setup a Clash project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-clash"><a class="header" href="#introduction-to-clash">Introduction to Clash</a></h1>
<h2 id="functional-hardware"><a class="header" href="#functional-hardware">Functional Hardware</a></h2>
<p><a href="https://clash-lang.org">Clash</a> is an open-source functional hardware description language (HDL) that closely mirrors the syntax and semantics of the <a href="https://www.haskell.org">Haskell</a> programming language.
It is used for creating hardware designs, typically for running on <em>field programmable gate arrays</em> (FPGAs) or <em>application-specific integrated circuits</em> (ASICs).</p>
<p>Clash is both a compiler, and a set of libraries for circuit design, that transform high level Haskell descriptions of synchronous, sequential logic into low-level <a href="https://en.wikipedia.org/wiki/VHDL">VHDL</a>, <a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a>, or <a href="https://en.wikipedia.org/wiki/SystemVerilog">SystemVerilog</a>.
It provides a unique approach to design of sequential circuits, with a high amount of abstraction power that blurs the line between strictly behavioral and structural synthesis approaches.</p>
<p>Clash aims to modernize the hardware development experience, making it easier to quickly and correctly develop complex circuit designs.
This is achieved by making Clash:</p>
<p><strong>Expressive</strong></p>
<p>Clash uses the Haskell type system to its full potential — including modern extensions and techniques — to bring a high level of type safety and expressiveness to hardware design.</p>
<p>This expressive typing makes it easier to develop safe, maintainable hardware.
Combinational and sequential logic is separated by type, and global safety invariants such as separating incompatible clock domains are enforced in the type system.</p>
<p><strong>Intuitive</strong></p>
<p>Clash makes it easy to express circuit designs in an intuitive manner, allowing high level structural components to be connected easily in designs.
Moreover, unlike most "high level synthesis" tools, this extends to precise control over register placement and pipelining.</p>
<p><strong>Interactive</strong></p>
<p>Unlike traditional HDL tools, Clash has a fully interactive <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">read-eval-print loop</a> (REPL), allowing circuits to be interactively designed and tested.</p>
<p><strong>Performant</strong></p>
<p>Clash reuses parts of the <a href="https://ghc.haskell.org">Glasgow Haskell Compiler</a> to provide fast simulation of circuits for development and testing.</p>
<p><strong>Efficient</strong></p>
<p>Clash uses a "whole program synthesis" approach in order to view the entire circuit at once, and optimizes this design before translating to a specific target.
This allows meaningful optimizations to be performed on the entire design.</p>
<p><strong>Extensible</strong></p>
<p>Additional primitives and black boxes can be added to Clash in the language of your choice, allowing you to use your own vendor or IP library within projects.</p>
<p>Clash allows seamless interoperability with libraries written in Haskell, including <code>mtl</code>, <code>lens</code> and <code>hedgehog</code>.
This makes it even easier to quickly prototype complex designs.</p>
<h2 id="intended-audience"><a class="header" href="#intended-audience">Intended Audience</a></h2>
<p>Clash is ideal for developers from different backgrounds, although the main intended audiences are</p>
<p><strong>Hardware Engineers</strong></p>
<p>You are a hardware engineer, used to using tools like <a href="https://en.wikipedia.org/wiki/VHDL">VHDL</a> and <a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a> to implement circuit designs.
Clash offers the familiar mixed simulation/synthesis capabilities of these tools, while providing a language with powerful abstractions.</p>
<p><strong>Haskell Programmers</strong></p>
<p>You are a <a href="https://www.haskell.org">Haskell</a> programmer, looking to start developing hardware.
Clash offers the ability to start prototyping and simulating designs in a familiar environment — lowering the learning curve significantly.</p>
<h2 id="maturity-and-support"><a class="header" href="#maturity-and-support">Maturity and Support</a></h2>
<p>Clash is a continually evolving tool, having been actively developed since 2009.
With the release of Clash 1.0 there has been an increased focus on maintaining API stability between releases, meaning circuit designs written in Clash should continue to work between minor releases.
Today, the Clash Compiler is actively developed by QBayLogic B.V., volunteers and students.</p>
<p>Several companies and enthusiasts are already using Clash to develop circuit designs, ranging from small designs on hobbyist boards to larger designs on modern FPGA and ASIC architectures.</p>
<p>While care is taken to thoroughly test the Clash compiler, some bugs may exist.
We encourage users to file issues, or contribute pull requests on our <a href="https://github.com/clash-lang/clash-compiler">GitHub repository</a>.</p>
<h2 id="open-source-community"><a class="header" href="#open-source-community">Open-source community</a></h2>
<p>Clash benefits from an active community. Whether you need a question answered or
want to contribute to open-source features, browse the features below to make
the most of Clash.</p>
<ul>
<li><a href="https://clash-lang.discourse.group/">Discourse: long form discussions and questions</a></li>
<li><a href="https://discord.gg/rebGq25FB4">Discord: short form discussions and community chat room</a></li>
<li><a href="https://functionalprogramming.slack.com/archives/CPGMJFF50">Slack: short form discussions and questions</a>
(Invite yourself at <a href="https://fpslack.com">fpslack.com</a>)</li>
<li><a href="https://github.com/clash-lang/clash-compiler/issues">Github: issue tracker</a></li>
</ul>
<h2 id="clash-version-numbering-policy"><a class="header" href="#clash-version-numbering-policy">Clash Version Numbering Policy</a></h2>
<p>Clash follows the <a href="https://pvp.haskell.org">Haskell PVP Specification</a> for its version numbers, for all packages.
The main libraries that make up the Clash compiler maintain the same version numbers, making it easy to identify which versions are compatible.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>Due to Clash's tight integration with GHC, updates to the GHC version that Clash uses result in changes to the Clash version.
As GHC's internals change frequently, even for minor bumps, it cannot be guaranteed that these changes will not result in Clash changes.</p>
</div>
<p>It is recommended (but not required) that downstream Clash packages and published Clash code also follow the PVP specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h1>
<p>Up to date release notes of the clash compiler can be found on the <a href="https://github.com/clash-lang/clash-compiler/releases">Github releases page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="basic-questions"><a class="header" href="#basic-questions">Basic Questions</a></h2>
<ul>
<li>
<p><strong>Q</strong>: How do I install Clash?</p>
<p><strong>A</strong>: Check out <a href="https://clash-lang.org/install">clash-lang.org/install</a> to install the latest stable release of Clash, or to setup a Clash project.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Is the name "Clash", "CLaSH", or "CλaSH"?</p>
<p><strong>A</strong>: It's <strong>Clash</strong>.</p>
<p>In its research stages Clash was called "CλaSH", an acronym for the <strong>C</strong>AES <strong>La</strong>nguage for <strong>S</strong>ynchronous <strong>H</strong>ardware.
CAES is a group of the Faculty of Electrical Engineering, Mathematics and Computer Science at the University of Twente.
Clash was originally developed by Christaan Baaij and supervisor Jan Kuper.
The stylization "CλaSH" is an homage to <a href="https://haskell.org">Haskell</a>, whose official logo has long been the venerable Greek <em>lambda</em> character.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Is Clash a "high-level synthesis" tool?</p>
<p><strong>A</strong>: While clash provides high-level language features, hardware descriptions written in Clash are not decoupled from clock-level timing.
Clash does therefore not offer what is generally understood as "high-level synthesis".
Compared to the big three hardware description languages, <em>VHDL</em>, <em>Verilog</em>, and <em>SystemVerilog</em>, Clash arguably <em>is</em> high-level.
It offers many of the powerful abstractions that modern software programming languages offer.
In fact, it inherits many of the software industry's bleeding-edge features by virtue of basing its implementation on Haskell.</p>
</li>
</ul>
<h2 id="clash-support"><a class="header" href="#clash-support">Clash Support</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Is Clash production ready?</p>
<p><strong>A</strong>: Clash is constantly evolving, and since the 1.0 release there is a focus on maintaining API backwards compatibility.
Clash is used successfully in real-world scenarios, and <a href="https://qbaylogic.com/clash-support.html">QBayLogic Clash support</a> can help with education and implementation of Clash projects.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Will Clash work with my EDA tools?</p>
<p><strong>A</strong>: In general, Clash should work well with Xilinx and Intel FPAGs and their EDA tools — as development typically focuses on these vendors.
Clash has also been successfully used on Microsemi (formerly Actel) SmartFusion 2 and Lattice Semiconductor iCE40 FPGAs, and some basic IP for these exist.</p>
<p>For most toolchains, the default primitives supplied by Clash should work with minimal effort.
If not, it is possible to call your vendor's library manually, or use a tool like <a href="http://clifford.at/yosys">Yosys</a> to do mapping.
It is also possible to consult <a href="https://qbaylogic.com/clash-support.html">QBayLogic Clash support</a> for more assistance.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Does Clash support <a href="http://clifford.at/icestorm">Project IceStorm</a>?</p>
<p><strong>A</strong>: The Verilog backend for Clash emits Verilog 2001, which is supported by <a href="http://clifford.at/yosys">Yosys</a>.
This means it can be placed and packed with <em>arachne-pnr</em> and <em>icestorm</em>.
Additionally, Clash has some support for the Lattice Semiconductor iCE40 FPGA.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Can Clash be used for ASIC designs, as well as FPGA designs?</p>
<p>Clash can be used for ASIC designs, however the RTL produced by Clash may not be immediately suitable as it is largely platform agnostic.
While this is not a problem for FPGAs, it can make developing ASICs more complicated as many ASIC vendors have different proprietary tool flows, with limited information available about their workings.</p>
<p>If you are using Clash to develop for ASIC, and need assistance with getting your toolchain to work, you can contact <a href="https://qbaylogic.com/clash-support.html">QBayLogic Clash support</a> for assistance.</p>
</li>
</ul>
<h2 id="clash-and-haskell"><a class="header" href="#clash-and-haskell">Clash and Haskell</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Is Clash its own programming language, or is it Haskell?</p>
<p><strong>A</strong>: Clash is a programming language in its own right, complete with its own executable and standard library.
Clash is also related to the Haskell programming language, and may be thought of as a dialect of Haskell for developing hardware.
While the surface syntax and typing rules are the same, the semantics change as code progresses through the compilation pipeline.</p>
<p>Due to the shared behavior in the early stages of the compiler, components from GHC (the most common Haskell compiler) are reused in the Clash compiler.
This is how Clash achieves such high interoperability with existing Haskell projects.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Clash has better inference for type level natural numbers than GHC.
How is this possible?</p>
<p><strong>A</strong>: Clash's enhanced type checking functionality is due to the use of GHC compiler plugins, which can be used in any Haskell project.
To enable these plugins, pass the following compiler flags to GHC:</p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise       #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Extra.Solver    #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
</code></pre>
<p>These plugins come from the <code>ghc-typelits-natnormalise</code>, <code>ghc-typelits-extra</code>, and <code>ghc-typelits-knownnat</code> packages respectively, which are all available from Hackage and Stackage.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Do I need to know Haskell in order to use Clash?</p>
<p><strong>A</strong>: As Clash is deeply integrated with Haskell, it is recommended that users have some familiarity with Haskell, or functional programming in general.
Clash uses some advanced features of Haskell, and real-world designs will often want to leverage the existing Haskell ecosystem.</p>
<p>For developers who are particularly familiar with either Haskell or hardware design, Clash should be relatively intuitive to use.
Additionally, obvious mistakes with designs will be identified and reported due to the strong type system identifying mistakes at compile-time.</p>
</li>
</ul>
<h2 id="clash-and-other-hdls"><a class="header" href="#clash-and-other-hdls">Clash and other HDLs</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Do I need to know existing RTL/HDL languages in order to use Clash?</p>
<p><strong>A</strong>: Clash currently outputs VHDL, Verilog, and SystemVerilog.
While it's not necessary to understand these descriptions, you will need to some understanding of vendor tools to actually deploy it.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: What's the difference between Clash and Lava?</p>
<p><strong>A</strong>: Lava dialects (including the modern variant <a href="https://github.com/mn416/blarney">Blarney</a>) are all embedded domain specific languages (EDSLs) inside Haskell.
On top of that they use a so-called <em>deep</em> embedding to be able to transform a circuit description into a netlist (to subsequently output that as a VHDL/Verilog file).
Clash on the other hand uses "standard" compiler techniques to create a netlist from the Haskell abstract syntax tree (AST).
This "standard" compiler technique enables the following features not available in (Haskell-based) EDSLs:</p>
<blockquote>
<ol>
<li>Clash allows the use of normal Haskell operations such as (==) on both the meta-level (how the program is structured/generated), and the object-level (the functionality of the program).</li>
<li>Clash allows the use of regular Haskell syntax to model the concept of 'choice' at the object-level (the functionality of the program): if-expressions, guards, case, etc.</li>
<li>Clash allows programmers to use native Haskell pattern matching.</li>
</ol>
</blockquote>
<p>Basically, with Clash you can use regular Haskell to describe the behavior of the circuit, most importantly all of it's choice-constructs (case-expressions, guards, etc.).
With an EDSL you are "limited" by the constructs of the DSL, making your circuit descriptions look less like regular Haskell functions.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: What's the difference between Clash and Chisel/Spinal/Migen/Hardcaml?</p>
<p><strong>A</strong>: The biggest difference between these toolchains and Clash is that Clash exists as a Haskell derivative, with a full synthesizing compiler to RTL — while Chisel/Spinal/Migen/Hardcaml exists as an embedding of hardware semantics inside Scala/Scala/Python/OCaml.
Aside from the "host language" differences, this means that Chisel/Spinal/Migen/Hardcaml are conceptually closer to something like Lava/Blarney than to Clash.
So within these languages you can only use the host language constructs to structure and compose the constructs of the EDSL, and you can't use host language constructs to describe the behavior of the circuit; i.e. you cannot use the host language's regular if-expression to model the concept of choice, but you have to use e.g. Chisel's <em>when</em>-function.</p>
<p>Aside from the above, there is also a varying degree of <em>native</em> simulation and interactivity.
In Clash you can evaluate/simulate any (sub-)component in the interactive interpreter for an immediate and localized design feedback loop.
The only EDSLs that have a similar interactive interpreter for fast design feedback are the older variants of Lava.
They used a so-called dual-embedding, where the EDSL primitives also contained a normal Haskell function which described their behavior, and so the composition of these primitives could be evaluated as a regular Haskell function.</p>
<p>The other EDSLs all offer simulation, but there is a higher latency to get from a design to a simulation of a design, and they are not as interactive.
Blarney emits Verilog, and you can then use a Verilog simulator to simulate the Blarney design.
Spinal also emits Verilog, but it then uses Verilator to compile it to an object-file which is loaded back into Scala, allowing you to interact with your Spinal design from within Scala.
Chisel is also not interpreted directly, instead, a Chisel description is "lowered" to FIRRTL where that FIRRTL description is then executed inside Scala by the FIRRTL interpreter.
Migen works similarly to Chisel as far as the approach to simulation goes, although perhaps more direct: it directly interprets its own deep embedding data structure (its <em>IR</em>) to enable native simulation.</p>
<p>All of this influences the style in which you write circuits and the creative process by which you come to a solution; the effects of this on the quality of results (QoR) and development time are, however, both hard to qualify and hard to quantify.
That is, although all of these languages, both the EDSLs and Clash, enable full control over the QoR (i.e. you can get as many registers and as much logic as you intended), the way in which you get there can vary from problem domain to problem domain and person to person.
If you have enough time, we encourage to try several of them and see which style is the most natural fit for you; if you're limited on time, we of course recommend that you just go with Clash ;-)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Clash is licensed under the <a href="https://spdx.org/licenses/BSD-2-Clause.html">BSD 2-Clause "Simplified" License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clash-as-a-language"><a class="header" href="#clash-as-a-language">Clash as a Language</a></h1>
<p>As Clash reuses parts of the GHC compiler for its frontend, the syntax and semantics should be familiar to Haskell programmers.
For people unfamiliar with Haskell, there are many resources to learn the language, such as</p>
<ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell">The Haskell Wikibook</a></li>
</ul>
<p>Clash does make some use of more advanced features of GHC Haskell, which are exposed by GHC as language extensions.
The extensions used by Clash are</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/binary_literals.html">BinaryLiterals</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/constraint_kind.html">ConstraintKinds</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/data_kinds.html">DataKinds</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/derive_any_class.html">DeriveAnyClass</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/generics.html#extension-DeriveGeneric">DeriveGeneric</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/deriving_extra.html#extension-DeriveLift">DeriveLift</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/deriving_strategies.html">DerivingStrategies</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/explicit_forall.html">ExplicitForAll</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/explicit_namespaces.html">ExplicitNamespaces</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/flexible_contexts.html">FlexibleContexts</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/instances.html#extension-FlexibleInstances">FlexibleInstances</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/kind_signatures.html">KindSignatures</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/magic_hash.html">MagicHash</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/let_generalisation.html?highlight=monolocalbinds#extension-MonoLocalBinds">MonoLocalBinds</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/numeric_underscores.html">NumericUnderscores</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/rebindable_syntax.html">NoImplicitPrelude</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/poly_kinds.html?#the-kind-type">NoStarIsType</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/strict.html#strict-by-default-data-types">NoStrictData</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/strict.html#strict-by-default-pattern-bindings">NoStrict</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/template_haskell.html#template-haskell-quasi-quotation">QuasiQuotes</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/scoped_type_variables.html">ScopedTypeVariables</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/template_haskell.html#extension-TemplateHaskellQuotes">TemplateHaskellQuotes</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/template_haskell.html">TemplateHaskell</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_applications.html">TypeApplications</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_families.html">TypeFamilies</a></li>
<li><a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_operators.html">TypeOperators</a></li>
</ul>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>Since GHC 8.6, the <code>StarIsType</code> extension is defined.
This extension is explicitly turned off by Clash, meaning <code>Data.Kind.Type</code> must be used to refer to Haskell types.</p>
</div>
<p>Clash also enables some GHC plugins by default which improve the type inference for type level numbers.
The plugins enabled by default are</p>
<ul>
<li><a href="https://hackage.haskell.org/package/ghc-typelits-extra">ghc-typelits-extra</a></li>
<li><a href="https://hackage.haskell.org/package/ghc-typelits-knownnat">ghc-typelits-knownnat</a></li>
<li><a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">ghc-typelits-natnormalise</a></li>
</ul>
<p>Users are free to control the language extensions and GHC options with the normal <code>OPTIONS_GHC</code> and <code>LANGUAGE</code> pragmas in source files.
For more information, see the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/">GHC User's Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clash-prelude"><a class="header" href="#clash-prelude">Clash Prelude</a></h1>
<h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<p>The Clash prelude includes many different numeric types, which are used to safely define other types/functions.
These include, but may not be limited to</p>
<ul>
<li>
<p>Type level natural numbers (<code>Nat</code>), which allow numbers to be used in types.
Conceptually, this is similar to <em>const generics</em> in <em>C++</em>.</p>
<p>It is possible to have term level values which refer to a type level number.
This is called <code>SNat n</code> (for <em>singleton natural number</em>).
These are defined up to 1024 with the prefix "d" (e.g. <code>d256</code>).</p>
</li>
<li>
<p><code>Unsigned n</code> and <code>Signed n</code> numbers with an arbitrary width (given as a type level natural number).
These allow fixed-width arithmetic to be used on arbitrary numbers.</p>
</li>
<li>
<p><code>Index n</code> provides natural numbers up to an arbitrary value (given as a type level natural number).
These allow indexing into fixed width structures like <code>Vec n a</code>.</p>
</li>
</ul>
<p>Another commonly used type is <code>BitVector n</code>.
This provides a fixed size vector of <code>Bit</code> values which can be indexed, and used to perform <em>unsigned integer arithmetic</em>.
Any type that can be marshaled to/from a <code>BitVector n</code> implements the <code>BitPack</code> class, which defines the conversion.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>It is also possible to derive instances of <code>BitPack</code> using <code>Generic</code>, by writing <code>deriving (Generic, BitPack)</code> in the type definition.
This automatically determines how to do the conversion at compile-time.</p>
</div>
<p>More generally, there is a <code>Vec n a</code> type which allows collections of arbitrary values to be used.
These vectors are tagged with their length, to prevent out of bounds access at compile-time.</p>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>The <code>Vec n a</code> type exports pattern synonyms for inserting at the left and right of a vector.
The types of the <code>Cons</code> constructor and <code>(:&gt;)</code> pattern are slightly different, and may behave differently in practice.</p>
<p>The <code>Cons</code> constructor has a more general type, allowing it to be used in some cases where the pattern cannot be used.
However, this additional power comes at the cost of type inference.
It is recommended that users use the <code>(:&gt;)</code> pattern by default, and only use <code>Cons</code> when necessary.</p>
</div>
<h2 id="synthesis-domains"><a class="header" href="#synthesis-domains">Synthesis Domains</a></h2>
<p>Synchronous circuits have a synthesis domain, which determines the behavior of things which can affect signals in the domain.
Domains consist of</p>
<ul>
<li>a name, which uniquely refers to the domain</li>
<li>the clock period in ps</li>
<li>the active edge of the clock</li>
<li>whether resets are synchronous (edge-sensitive) or not</li>
<li>whether the initial (power up) behavior is defined</li>
<li>whether resets are high or low polarity</li>
</ul>
<p>The prelude provides some common domains, namely <code>XilinxSystem</code> and <code>IntelSystem</code> for the standard configurations of each vendor.
There is also a generic domain, <code>System</code>, which can be used for vendor-agnostic purposes (e.g., writing a generic test bench).
It is possible to define new synthesis domains for custom hardware using the <code>createDomain</code> function, which also defines the necessary instances for domains.</p>
<p>A value in a synchronous circuit is wrapped in the <code>Signal dom a</code> type, which specifies the synthesis domain and the type of value.
Any function which needs access to a domain can use the constraint <code>KnownDomain</code> to extract configuration.</p>
<p>The default API exposed by the prelude is implicit with regards to clocks, reset lines and enable lines, as these can be determined at compile time.
However, if they are needed the <code>Clash.Explicit</code> module contains explicit versions of the API which expose these directly in function arguments.
It is also possible to use functions like <code>exposeClockResetEnable</code> to turn an implicitly defined function to an explicitly defined function.</p>
<h2 id="state-machines"><a class="header" href="#state-machines">State Machines</a></h2>
<p>The Clash prelude contains combinators for two classical finite state machines which can be used to define synchronous circuits.
The first of these is <code>mealy</code>, which encodes a <a href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy machine</a>.
This is a machine specified by</p>
<ul>
<li>A transition function of type <code>state -&gt; input -&gt; (state, output)</code></li>
<li>An initial state</li>
<li>An input signal which can change at each cycle</li>
</ul>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>The Mealy machine is similar to the <code>State</code> monad, which Haskell programmers may already be familiar with.
Practically speaking, the only difference is that this machine also has an input signal which is changed externally to the definition of the machine.</p>
</div>
<p>It is also possible to define a <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore machine</a> using the <code>moore</code> function in the Clash prelude.
This differs from the Mealy machine by providing output based on the previous state (as opposed to the newly calculated state), and is specified by</p>
<ul>
<li>A transition function of type <code>state -&gt; input -&gt; state</code></li>
<li>An output function of type <code>state -&gt; output</code></li>
<li>An initial state</li>
<li>An input signal which can change at each cycle</li>
</ul>
<p>Sometimes, there may be multiple inputs/outputs needed for a machine.
As machines only input and output a single signal, there is a way to combine and separate multiple signals.
The <code>Bundle</code> class specifies how to convert between some type which is a signal of a product, and some type which is a product of signals, e.g.</p>
<pre><code class="language-haskell">bundle   :: (Signal dom a, Signal dom b) -&gt; Signal dom (a, b)
unbundle :: Signal dom (a, b) -&gt; (Signal dom a, Signal dom b)
</code></pre>
<p>There are combinators which can automatically perform this bundling and unbundling for you as required, called <code>mealyB</code> and <code>mooreB</code>.
The <code>Bundle</code> class is already defined for many types, including tuples (up to 62 elements), <code>Maybe a</code>, <code>Either a b</code> and <code>Vec n a</code>.</p>
<h2 id="ram-and-rom"><a class="header" href="#ram-and-rom">RAM and ROM</a></h2>
<p>The Clash prelude provides the ability to work with synchronous and asynchronous ROM, asynchronous RAM and synchronous Block RAM.
The simplest of these are ROMs, which only allow indexing into a <code>Vec n a</code> of elements.
ROM is defined using the functions in <code>Clash.Prelude.ROM</code>.</p>
<p>RAM is more complex, as it allows both reading and writing.
The function to define a RAM takes in a signal for the address to read, and a signal for an optional address to update (bundled with the new value).
The RAM outputs the value of the memory at the requested read address.
Asynchronous RAM is defined in <code>Clash.Prelude.RAM</code>.</p>
<p>An FPGA may include a block RAM, which is a larger memory structure and more suitable for some applications.
Block RAM has a synchronous read port, allowing memory access to be synchronized to a clock.
Block RAM has a one-cycle delay, meaning that it outputs the value in memory pointed to by the read address input from the <em>previous</em> cycle.
Block RAM is defined in <code>Clash.Prelude.BlockRam</code>.</p>
<h2 id="undefined-values"><a class="header" href="#undefined-values">Undefined Values</a></h2>
<p>When working with hardware designs, there are times when undefined values may be encountered in simulation.
Clash provides a custom exception type, <code>XException</code>, for cases when an undefined value is encountered.
There are also many utility functions for working with exceptions, such as</p>
<ul>
<li><code>errorX</code>, which throws an <code>XException</code></li>
<li><code>isX</code> and <code>hasX</code>, which check for <code>XExceptions</code> when evaluating</li>
<li><code>maybeIsX</code> and <code>maybeHasX</code>, which discard information about exceptions</li>
</ul>
<p>There are also implementations of typical classes in Haskell which have been changed to work with undefined values.
Currently these are</p>
<ul>
<li><code>ShowX</code>, which works like the <code>Show</code> class in Haskell.
When an undefined value is encountered, <code>undefined</code> is printed.
<code>Show</code> can still be used, but will throw an exception if an undefined value is encountered.</li>
<li><code>NFDataX</code>, which works like the <code>NFData</code> class in the <code>deepseq</code> library.
This allows evaluating values to normal form in code when <code>XException</code> may be present.
<code>NFData</code> can still be used, but will bubble up exceptions if <code>XException</code> is encountered.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clash-compiler-flags"><a class="header" href="#clash-compiler-flags">Clash Compiler Flags</a></h1>
<p><code>--vhdl</code><br />
Use the VHDL backend for code generation.
This currently emits VHDL 1993 source which can be consumed by other tools.</p>
<p><code>--verilog</code><br />
Use the Verilog backend for code generation.
This currently emits Verilog 2001 source which can be consumed by other tools.</p>
<p><code>--systemverilog</code><br />
Use the SystemVerilog backend for code generation.
This currently emits SystemVerilog 2012 source which can be consumed by other tools.</p>
<p><code>-fclash-debug</code><br />
Set the debugging mode for the compiler, exposing additional output.
The available options are</p>
<ul>
<li><code>DebugNone</code> to show no debug messages</li>
<li><code>DebugSilent</code> to test invariants and error if any are violated.
This is implicitly enabled by any debug flag.</li>
<li><code>DebugFinal</code> to show expressions after they have been completely normalized</li>
<li><code>DebugCount</code> to count how often each transformation is applied</li>
<li><code>DebugName</code> to show the names of transformations as they are applied</li>
<li><code>DebugTry</code> to show names of tried and applied transformations</li>
<li><code>DebugApplied</code> to show sub-expressions after they are rewritten</li>
<li><code>DebugAll</code> to show all sub-expressions when a rewrite is attempted</li>
</ul>
<p><strong>Default:</strong> <code>DebugNone</code></p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>This flag exists for backwards compatibility.
It is now possible to set debugging flags individually with
<span class="title-ref"><code>-fclash-debug-invariants</code></span>,
<span class="title-ref"><code>-fclash-debug-info</code></span> and
<span class="title-ref"><code>-fclash-debug-count-transformations</code></span>.</p>
</div>
<p><code>-fclash-debug-invariants</code><br />
Check invariants while debugging and print warnings/errors which may be useful, such as alerting when unexpected changes occur or when a transformation introduces free variables / shadowing.</p>
<p><code>-fclash-debug-info</code><br />
Specify the information to show about individual transformations while debugging.
From least to most information, these are</p>
<ul>
<li><code>None</code> to show no information</li>
<li><code>FinalTerm</code> to show the final result of normalization</li>
<li><code>AppliedName</code> to show the names of applied transformations</li>
<li><code>AppliedTerm</code> to show the result of applied transformations</li>
<li><code>TryName</code> to show the names of attempted transformations, as well as the result of any transformations which are applied</li>
<li><code>TryTerm</code> to show the names and results of all transformations attempted whether they were applied or not</li>
</ul>
<p><strong>Default:</strong> <code>None</code></p>
<p><code>-fclash-debug-count-transformations</code><br />
Count the transformations that are applied and print a summary at the end of the normalization phase.</p>
<p><code>-fclash-debug-history[=FILENAME]</code><br />
Saves all applied rewrites into <code>FILENAME</code>, for later analysis with the clash-term tool.
When no filename is given it defaults to <code>history.dat</code>.</p>
<p><code>-fclash-debug-transformations</code><br />
List the transformations that are to be debugged.
This is given as a comma-separated list of transformations, e.g.</p>
<pre><code class="language-bash">clash -fclash-debug-transformations inlineNonRep,topLet,appProp
</code></pre>
<p><strong>Default:</strong> <code>[]</code></p>
<p><code>-fclash-debug-transformations-from=N</code><br />
Only print debug output from applied transformation <code>N</code> and onwards.</p>
<pre><code class="language-bash">clash -fclash-debug-transformations-from=21570
</code></pre>
<p><strong>Default:</strong> <code>0</code></p>
<p><code>-fclash-debug-transformations-limit=N</code><br />
Only print debug output for <code>N</code> applied transformations.</p>
<pre><code class="language-bash">clash -fclash-debug-transformations-limit=12
</code></pre>
<p><strong>Default:</strong> <code>MAX_INT</code></p>
<p><code>-fclash-hdldir</code><br />
Specify the directory that generated HDL is written into.
For example</p>
<pre><code class="language-bash">clash -fclash-hdldir build/hdl
</code></pre>
<p>will create a directory <code>build/hdl</code></p>
<p><strong>Default:</strong> Either <code>vhdl</code>, <code>verilog</code>, or <code>systemverilog</code> depending on the synthesis target.</p>
<p><code>-fclash-hdlsyn</code><br />
Specify the HDL synthesis tool which will be used.
Available options are <code>Vivado</code>, <code>Quartus</code> and <code>Other</code>, but some synonyms for these exist (<code>Xilinx</code> and <code>ISE</code> are synonyms for <code>Vivado</code>, <code>Altera</code> and <code>Intel</code> are synonyms for <code>Quartus</code>).</p>
<p><strong>Default:</strong> <code>Other</code></p>
<p><code>-fclash-no-cache</code><br />
Don't reuse previously generated output from Clash, instead generating HDL from a clean state.
While this leads to longer builds, it can be useful in development.</p>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>Previously this flag was called <code>-fclash-nocache</code>, however this is now deprecated.</p>
</div>
<p><strong>Default:</strong> Cache generated HDL</p>
<p><code>-fclash-no-check-inaccessible-idirs</code><br />
Check that all include directories (containing primitives) exist when running Clash.
If any directory does not exist, an error is thrown.</p>
<p><strong>Default:</strong> Check directories</p>
<p><code>-fclash-clear</code><br />
Remove HDL directories before writing to them (if cache can't be used).
By default, Clash will only write to non-empty directories if it can prove all files in it are generated by a previous run.
This option applies to directories of the various top entities, i.e., the subdirectories made in the directory passed in with <code>-fclash-hdldir</code>.</p>
<p><strong>Default:</strong> Clean before build</p>
<p><code>-fclash-no-prim-warn</code><br />
Disable warnings for primitives that are annotated with <code>warnAlways</code>.
This means warnings from annotations like</p>
<pre><code class="language-haskell">{-# ANN f (warnAlways "This primitive is dangerous") #-}
</code></pre>
<p>will not be shown when compiling.</p>
<p><strong>Default:</strong> Show warnings</p>
<p><code>-fclash-spec-limit</code><br />
Change the number of times a function can undergo specialization.</p>
<p><strong>Default:</strong> 20</p>
<p><code>-fclash-inline-limit</code><br />
Change the number of times a function <code>f</code> can undergo inlining inside some other function <code>g</code>.
This prevents the size of <code>g</code> growing dramatically.</p>
<p><strong>Default:</strong> 20</p>
<p><code>-fclash-inline-function-limit</code><br />
Set the threshold for function size.
Below this threshold a function is always inlined (if it is not recursive).</p>
<p><strong>Default:</strong> 15</p>
<p><code>-fclash-inline-constant-limit</code><br />
Set the threshold for constant size.
Below this threshold constants are always inlined.
A value of 0 inlines all constants.</p>
<p><strong>Default:</strong> 0</p>
<p><code>-fclash-evaluator-fuel-limit</code><br />
Set the threshold for unfolding potentially non-terminating bindings in the evaluator.
A value of 0 only unfolds terminating bindings.</p>
<p><strong>Default:</strong> 20</p>
<p><code>-fclash-intwidth</code><br />
Set the bit width for the <code>Int/Word/Integer</code> types in the generated HDL.
Clash simulation is not affected, and neither are <code>BitPack</code> instances.
The only allowed values are 32 or 64.</p>
<p><strong>Default:</strong> Machine word size (<code>WORD_SIZE_IN_BITS</code>)</p>
<p><code>-fclash-error-extra</code><br />
Print additional information with compiler errors if it as available.
If there is extra information and this flag is not enabled, a message will be printed suggesting this flag.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-float-support</code><br />
Enable support for floating point numbers.
If this is disabled, Clash will not attempt to convert Float and Double values for hardware.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-component-prefix</code><br />
Prefix the names of generated HDl components with a string.
For example a component <code>foo</code> would be called <code>xcorp_foo</code> if run with</p>
<pre><code class="language-bash">clash -fclash-component-prefix "xcorp"
</code></pre>
<p><strong>Default:</strong> ""</p>
<p><code>-fclash-old-inline-strategy</code><br />
The new inlining strategy for Clash inlines all functions which are not marked with <code>NOINLINE</code> or a synthesize attribute.
The old inlining strategy differed, attempting only to inline functions which were deemed "cheap".
The old inlining strategy may be quicker in practice for some circuits.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-no-escaped-identifiers</code><br />
Disable extended identifiers, as used in some HDLs like VHDL to allow more flexibility with names.
Clash will only generate basic identifiers if this is used.</p>
<p><strong>Default:</strong> Escaped identifiers are allowed</p>
<p><code>-fclash-lower-case-basic-identifiers</code><br />
Clash will only generate lower case basic identifiers if this is used.
This affects places where the various HDLs only allow basic identifiers to be used, most notably module and file names.</p>
<p><strong>Default:</strong> Disabled</p>
<p><code>-fclash-compile-ultra</code><br />
Aggressively run the normalizer, potentially gaining much better runtime performance at the expense of compile time.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-force-undefined{,0,1}</code><br />
Set the value to use when an undefined value is inserted into generated HDL.
This flag can be suffixed with either 0 or 1 to force use of that bit, or left without a suffix to use a HDL-specific default (e.g. <code>x</code> in Verilog).</p>
<p><strong>Default:</strong> Disabled</p>
<p><code>-fclash-aggressive-x-optimization</code><br />
Remove all undefined branches from case expressions, replacing them with another defined value in the expression.
If only one branch is defined, the case expression is elided completely.
If no branches are defined the entire expression is replaced with a call to <code>errorX</code>.</p>
<p><strong>Implies:</strong> <code>-fclash-aggressive-x-optimization-blackboxes</code></p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-aggressive-x-optimization-blackboxes</code><br />
Allow blackboxes to detect undefined values and change their behavior accordingly.
For example, if <code>register</code> is used in combination with an undefined reset value, it will leave out the reset logic entirely.
This flag is enabled when using <code>-fclash-aggressive-x-optimization</code>.</p>
<p><strong>Default:</strong> False</p>
<p><code>-fclash-edalize</code><br />
Generate metadata for use with <a href="https://github.com/olofk/edalize">Edalize</a>.
This generates edam.py files in all top entities with the configuration for building that entity.
Users still need to edit this file to specify the EDA tool to use, and if necessary the device to target (for Quartus, Vivado etc.).</p>
<p><strong>Default:</strong> False</p>
<p><code>-main-is</code><br />
When using one of <code>--vhdl</code>, <code>--verilog</code>, or <code>--systemverilog</code>, this flag refers to the synthesis target.
For example, running Clash with <code>clash My.Module -main-is top --vhdl</code> would synthesize <code>My.Module.top</code>.</p>
<p><code>-fclash-timescale-precision</code><br />
Sets the second part of Verilog's <code>timescale 100fs/100fs</code>.
E.g., setting this flag to <code>1fs</code> would make Clash generate Verilog files with <code>timescale 100fs/1fs</code> as their header.</p>
<p><strong>Default:</strong> <code>100fs</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synthesize-annotations-controlling-vhdlsystemverilog-generation"><a class="header" href="#synthesize-annotations-controlling-vhdlsystemverilog-generation">Synthesize annotations: controlling VHDL/(System)Verilog generation.</a></h1>
<p><code>Synthesize</code> annotations allow us to control hierarchy and naming aspects of the Clash compiler, specifically, they allow us to:</p>
<ul>
<li>Assign names to entities (VHDL) / modules ((System)Verilog), and their ports.</li>
<li>Put generated HDL files of a logical (sub)entity in their own directory.</li>
<li>Use cached versions of generated HDL, i.e., prevent recompilation of (sub)entities that have not changed since the last run.
Caching is based on a <code>.manifest</code> which is generated alongside the HDL; deleting this file means deleting the cache; changing this file will result in <em>undefined</em> behavior.</li>
</ul>
<p>Functions with a <code>Synthesize</code> annotation must adhere to the following restrictions:</p>
<ul>
<li>Although functions with a <code>Synthesize</code> annotation can of course depend on functions with another <code>Synthesize</code> annotation, they must not be mutually recursive.</li>
<li>Functions with a <code>Synthesize</code> annotation must be completely <em>monomorphic</em> and <em>first-order</em>, and cannot have any <em>non-representable</em> arguments or result.</li>
</ul>
<p>Also take the following into account when using <code>Synthesize</code> annotations.</p>
<ul>
<li>The Clash compiler is based on the GHC Haskell compiler, and the GHC machinery does not understand <code>Synthesize</code> annotations and it might subsequently decide to inline those functions.
You should therefore also add a <code>{-# OPAQUE f #-}</code> pragma to the functions which you give a <code>Synthesize</code> annotation.</li>
<li>Functions with a <code>Synthesize</code> annotation will not be specialized on constants.</li>
</ul>
<p>Finally, the root module, the module which you pass as an argument to the Clash compiler must either have:</p>
<ul>
<li>A function with a <code>Synthesize</code> annotation.</li>
<li>A function called <em>topEntity</em>.</li>
</ul>
<p>You apply <code>Synthesize</code> annotations to functions using an <code>ANN</code> pragma:</p>
<pre><code class="language-haskell">{-# OPAQUE topEntity #-}
{-# ANN topEntity (Synthesize {t_name = ..., ...  }) #-}
topEntity x = ...
</code></pre>
<p>For example, given the following specification:</p>
<pre><code class="language-haskell">module Blinker where

import Clash.Signal
import Clash.Prelude
import Clash.Intel.ClockGen

createDomain vSystem{vName="DomInput", vPeriod=20000, vResetPolarity=ActiveLow}
createDomain vSystem{vName="Dom100", vPeriod=10000}

topEntity
  :: Clock DomInput
  -&gt; Reset DomInput
  -&gt; Signal Dom100 Bit
  -&gt; Signal Dom100 (BitVector 8)
topEntity clk rst =
  exposeClockResetEnable (mealy blinkerT (1,False,0) . isRising 1) pllOut pllRst enableGen
 where
  (pllOut,pllRst) = altpllSync clk rst

blinkerT (leds,mode,cntr) key1R = ((ledsN,modeN,cntrN),leds)
 where
  -- clock frequency = 100e6  (100 MHz)
  -- led update rate = 333e-3 (every 333ms)
  cnt_max = maxBound :: Index 33300000 -- 100e6 * 333e-3

  cntrN | cntr == cnt_max = 0
        | otherwise       = cntr + 1

  modeN | key1R     = not mode
        | otherwise = mode

  ledsN | cntr == 0 = if mode then complement leds
                              else rotateL leds 1
        | otherwise = leds
</code></pre>
<p>The Clash compiler will normally generate the following <code>topentity.vhdl</code> file:</p>
<pre><code class="language-vhdl">-- Automatically generated VHDL-93
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.MATH_REAL.ALL;
use std.textio.all;
use work.all;
use work.Blinker_topEntity_types.all;

entity topEntity is
  port(-- clock
       clk    : in Blinker_topEntity_types.clk_DomInput;
       -- reset
       rst    : in Blinker_topEntity_types.rst_DomInput;
       eta    : in std_logic;
       result : out std_logic_vector(7 downto 0));
end;

architecture structural of topEntity is
 ...
end;
</code></pre>
<p>However, if we add the following <code>Synthesize</code> annotation in the file:</p>
<pre><code class="language-haskell">{-# OPAQUE topEntity #-}
{-# ANN topEntity
  (Synthesize
    { t_name   = "blinker"
    , t_inputs = [PortName "CLOCK_50", PortName "KEY0", PortName "KEY1"]
    , t_output = PortName "LED"
    }) #-}
</code></pre>
<p>The Clash compiler will generate the following <code>blinker.vhdl</code> file instead:</p>
<pre><code class="language-vhdl">-- Automatically generated VHDL-93
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.MATH_REAL.ALL;
use std.textio.all;
use work.all;
use work.blinker_types.all;

entity blinker is
  port(-- clock
       CLOCK_50 : in blinker_types.clk_DomInput;
       -- reset
       KEY0     : in blinker_types.rst_DomInput;
       KEY1     : in std_logic;
       LED      : out std_logic_vector(7 downto 0));
end;

architecture structural of blinker is
 ...
end;
</code></pre>
<p>Where we now have:</p>
<ul>
<li>A top-level component that is called <code>blinker</code>.</li>
<li>Inputs and outputs that have a <em>user</em>-chosen name: <code>CLOCK_50</code>, <code>KEY0</code>, <code>KEY1</code>, <code>LED</code>, etc.</li>
</ul>
<p>See the documentation of <code>Synthesize</code> for the meaning of all its fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-primitives"><a class="header" href="#user-defined-primitives">User-defined primitives</a></h1>
<p>There are times when you already have an existing piece of IP, or there are times where you need the HDL to have a specific shape so that the HDL synthesis tool can infer a specific component.
In these specific cases you can resort to defining your own HDL primitives.
Actually, most of the primitives in Clash are specified in the same way as you will read about in this section.
There are perhaps 10 (at most) functions which are truly hard-coded into the Clash compiler.
You can take a look at the files in <a href="https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/vhdl">https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/vhdl</a> (or <a href="https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/verilog">https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/verilog</a> for the Verilog primitives or <a href="https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/systemverilog">https://github.com/clash-lang/clash-compiler/tree/master/clash-lib/prims/systemverilog</a> for the SystemVerilog primitives) if you want to know which functions are defined as "regular" primitives.
The compiler looks for primitives in four locations:</p>
<ul>
<li>
<p>The official install location: e.g.</p>
<ul>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/common</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/commonverilog</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/systemverilog</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/verilog</code></li>
<li><code>$HOME/.stack/snapshots/x86_64-linux/&lt;HASH&gt;/share/&lt;GHC_VERSION&gt;/clash-lib-&lt;VERSION&gt;/prims/vhdl</code></li>
</ul>
</li>
<li>
<p>Directories indicated by a <code>Clash.Annotations.Primitive.Primitive</code> annotation</p>
</li>
<li>
<p>The current directory (the location given by <code>pwd</code>)</p>
</li>
<li>
<p>The include directories specified on the command-line: <code>-i&lt;DIR&gt;</code></p>
</li>
</ul>
<p>Where redefined primitives in the current directory or include directories will overwrite those in the official install location.
For now, files containing primitive definitions must have a <code>.primitives.yaml</code> file-extension.</p>
<p>Clash differentiates between two types of primitives, <em>expression</em> primitives and <em>declaration</em> primitives, corresponding to whether the primitive is an HDL <em>expression</em> or an HDL <em>declaration</em>.
We will first explore <em>expression</em> primitives, using <code>Signed</code> multiplication (<code>*</code>) as an example.
The <code>Clash.Sized.Internal.Signed</code> module specifies multiplication as follows:</p>
<pre><code class="language-haskell">(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n
(S a) *# (S b) = fromInteger_INLINE (a * b)
{-# OPAQUE (*#) #-}
</code></pre>
<p>For which the VHDL <em>expression</em> primitive is:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Sized.Internal.Signed.*#
  kind: Expression
  type: '(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n'
  template: resize(~ARG[1] * ~ARG[2], ~LIT[0])
</code></pre>
<p>The <code>name</code> of the primitive is the <em>fully qualified</em> name of the function you are creating the primitive for.
Because we are creating an <em>expression</em> primitive the kind must be set to <code>Expression</code>.
As the name suggest, it is a VHDL <em>template</em>, meaning that the compiler must fill in the holes heralded by the tilde (~).
Here:</p>
<ul>
<li><code>~ARG[1]</code> denotes the second argument given to the <code>(*#)</code> function, which corresponds to the LHS of the (<code>*</code>) operator.</li>
<li><code>~ARG[2]</code> denotes the third argument given to the <code>(*#)</code> function, which corresponds to the RHS of the (<code>*</code>) operator.</li>
<li><code>~LIT[0]</code> denotes the first argument given to the <code>(*#)</code> function, with the extra condition that it must be a <code>LIT</code>eral.
If for some reason this first argument does not turn out to be a literal then the compiler will raise an error.
This first arguments corresponds to the <code>KnownNat n</code> class constraint.</li>
</ul>
<p>An extensive list with all of the template holes will be given the end of this section. What we immediately notice is that class constraints are counted as normal arguments in the primitive definition.
This is because these class constraints are actually represented by ordinary record types, with fields corresponding to the methods of the type class.
In the above case, <code>KnownNat</code> is actually just like a <code>newtype</code> wrapper for <code>Natural</code>.</p>
<p>The second kind of primitive that we will explore is the <em>declaration</em> primitive.
We will use <code>blockRam#</code> as an example, for which the Haskell/Clash code is:</p>
<pre><code class="language-haskell">{-# LANGUAGE BangPatterns #-}

module BlockRam where

import Clash.Explicit.Prelude
import Clash.Annotations.Primitive (hasBlackBox)
import Clash.Signal.Internal (Clock, Signal (..), (.&amp;&amp;.))
import Clash.Sized.Vector (Vec, toList)
import Clash.XException (defaultSeqX)

import qualified Data.Vector as V
import GHC.Stack (HasCallStack, withFrozenCallStack)

blockRam#
  :: ( KnownDomain dom
     , HasCallStack
     , NFDataX a )
  =&gt; Clock dom           -- ^ Clock to synchronize to
  -&gt; Enable dom          -- ^ Global enable
  -&gt; Vec n a             -- ^ Initial content of the BRAM, also
                         -- determines the size, @n@, of the BRAM.
                         --
                         -- __NB__: __MUST__ be a constant.
  -&gt; Signal dom Int      -- ^ Read address @r@
  -&gt; Signal dom Bool     -- ^ Write enable
  -&gt; Signal dom Int      -- ^ Write address @w@
  -&gt; Signal dom a        -- ^ Value to write (at address @w@)
  -&gt; Signal dom a        -- ^ Value of the BRAM at address @r@ from
                         -- the previous clock cycle
blockRam# (Clock _) gen content rd wen =
  go
    (V.fromList (toList content))
    (withFrozenCallStack (deepErrorX "blockRam: intial value undefined"))
    (fromEnable gen)
    rd
    (fromEnable gen .&amp;&amp;. wen)
 where
  go !ram o ret@(~(re :- res)) rt@(~(r :- rs)) et@(~(e :- en)) wt@(~(w :- wr)) dt@(~(d :- din)) =
    let ram' = d `defaultSeqX` upd ram e (fromEnum w) d
        o'   = if re then ram V.! r else o
    in  o `seqX` o :- (ret `seq` rt `seq` et `seq` wt `seq` dt `seq` go ram' o' res rs en wr din)

  upd ram we waddr d = case maybeIsX we of
    Nothing -&gt; case maybeIsX waddr of
      Nothing -&gt; V.map (const (seq waddr d)) ram
      Just wa -&gt; ram V.// [(wa,d)]
    Just True -&gt; case maybeIsX waddr of
      Nothing -&gt; V.map (const (seq waddr d)) ram
      Just wa -&gt; ram V.// [(wa,d)]
    _ -&gt; ram
{-# OPAQUE blockRam# #-}
{-# ANN blockRam# hasBlackBox #-}
</code></pre>
<p>And for which the <em>declaration</em> primitive is:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Explicit.BlockRam.blockRam#
  kind: Declaration
  type: |-
    blockRam#
      :: ( KnownDomain dom        ARG[0]
         , HasCallStack  --       ARG[1]
         , NFDataX a )   --       ARG[2]
      =&gt; Clock dom       -- clk,  ARG[3]
      -&gt; Enable dom      -- en,   ARG[4]
      -&gt; Vec n a         -- init, ARG[5]
      -&gt; Signal dom Int  -- rd,   ARG[6]
      -&gt; Signal dom Bool -- wren, ARG[7]
      -&gt; Signal dom Int  -- wr,   ARG[8]
      -&gt; Signal dom a    -- din,  ARG[9]
      -&gt; Signal dom a
  template: |-
    -- blockRam begin
    ~GENSYM[~RESULT_blockRam][1] : block
      signal ~GENSYM[~RESULT_RAM][2] : ~TYP[5] := ~CONST[5];
      signal ~GENSYM[rd][4]  : integer range 0 to ~LENGTH[~TYP[5]] - 1;
      signal ~GENSYM[wr][5]  : integer range 0 to ~LENGTH[~TYP[5]] - 1;
    begin
      ~SYM[4] &lt;= to_integer(~ARG[6])
      -- pragma translate_off
                    mod ~LENGTH[~TYP[5]]
      -- pragma translate_on
                    ;
      ~SYM[5] &lt;= to_integer(~ARG[8])
      -- pragma translate_off
                    mod ~LENGTH[~TYP[5]]
      -- pragma translate_on
                    ;
    ~IF ~VIVADO ~THEN
      ~SYM[6] : process(~ARG[3])
      begin
        if ~IF~ACTIVEEDGE[Rising][0]~THENrising_edge~ELSEfalling_edge~FI(~ARG[3]) then
          if ~ARG[7] ~IF ~ISACTIVEENABLE[4] ~THEN and ~ARG[4] ~ELSE ~FI then
            ~SYM[2](~SYM[5]) &lt;= ~TOBV[~ARG[9]][~TYP[9]];
          end if;
          ~RESULT &lt;= fromSLV(~SYM[2](~SYM[4]))
          -- pragma translate_off
          after 1 ps
          -- pragma translate_on
          ;
        end if;
      end process; ~ELSE
      ~SYM[6] : process(~ARG[3])
      begin
        if ~IF~ACTIVEEDGE[Rising][0]~THENrising_edge~ELSEfalling_edge~FI(~ARG[3]) then
          if ~ARG[7] ~IF ~ISACTIVEENABLE[4] ~THEN and ~ARG[4] ~ELSE ~FI then
            ~SYM[2](~SYM[5]) &lt;= ~ARG[9];
          end if;
          ~RESULT &lt;= ~SYM[2](~SYM[4])
          -- pragma translate_off
          after 1 ps
          -- pragma translate_on
          ;
        end if;
      end process; ~FI
    end block;
    --end blockRam
</code></pre>
<p>Again, the <code>name</code> of the primitive is the fully qualified name of the function you are creating the primitive for.
Because we are creating a <em>declaration</em> primitive the <em>kind</em> must be set to <code>Declaration</code>.
Instead of discussing what the individual template holes mean in the above context, we will instead just give a general listing of the available template holes:</p>
<ul>
<li><code>~RESULT</code>: Signal to which the result of a primitive must be assigned to.
NB: Only used in a <em>declaration</em> primitive.</li>
<li><code>~ARG[N]</code>: <code>(N+1)</code>'th argument to the function.</li>
<li><code>~CONST[N]</code>: <code>(N+1)</code>'th argument to the function.
Like <code>~ARG</code>, but Clash will try to reduce this to a literal, even if it would otherwise consider it too expensive.
And if Clash fails to reduce this argument to a literal it will produce an error.</li>
<li><code>~LIT[N]</code>: <code>(N+1)</code>'th argument to the function.
Like <code>~CONST</code> but values are rendered as a bare literals, without any size or type annotations.
This only works for numeric types, and not for BitVector.</li>
<li><code>~TYP[N]</code>: VHDL type of the <code>(N+1)</code>'th argument.</li>
<li><code>~TYPO</code>: VHDL type of the result.</li>
<li><code>~TYPM[N]</code>: VHDL type<em>name</em> of the <code>(N+1)</code>'th argument; used in <em>type qualification</em>.</li>
<li><code>~TYPMO</code>: VHDL type<em>name</em> of the result; used in <em>type qualification</em>.</li>
<li><code>~ERROR[N]</code>: Error value for the VHDL type of the <code>(N+1)</code>'th argument.</li>
<li><code>~ERRORO</code>: Error value for the VHDL type of the result.</li>
<li><code>~GENSYM[&lt;NAME&gt;][N]</code>: Create a unique name, trying to stay as close to the given <code>&lt;NAME&gt;</code> as possible.
This unique symbol can be referred to in other places using <code>~SYM[N]</code>.</li>
<li><code>~SYM[N]</code>: a reference to the unique symbol created by <code>~GENSYM[&lt;NAME&gt;][N]</code>.</li>
<li><code>~SIGD[&lt;HOLE&gt;][N]</code>: Create a signal declaration, using <code>&lt;HOLE&gt;</code> as the name of the signal, and the type of the <code>(N+1)</code>'th argument.</li>
<li><code>~SIGDO[&lt;HOLE&gt;]</code>: Create a signal declaration, using <code>&lt;HOLE&gt;</code> as the name of the signal, and the type of the result.</li>
<li><code>~TYPEL[&lt;HOLE&gt;]</code>: The element type of the vector type represented by <code>&lt;HOLE&gt;</code>.
The content of <code>&lt;HOLE&gt;</code> must either be: <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~COMPNAME</code>: The name of the component in which the primitive is instantiated.</li>
<li><code>~LENGTH[&lt;HOLE&gt;]</code>: The vector length of the type represented by <code>&lt;HOLE&gt;</code>.</li>
<li><code>~DEPTH[&lt;HOLE&gt;]</code>: The tree depth of the type represented by <code>&lt;HOLE&gt;</code>.
The content of <code>&lt;HOLE&gt;</code> must either be: <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~SIZE[&lt;HOLE&gt;]</code>: The number of bits needed to encode the type represented by <code>&lt;HOLE&gt;</code>.
The content of <code>&lt;HOLE&gt;</code> must either be: <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~IF &lt;CONDITION&gt; ~THEN &lt;THEN&gt; ~ELSE &lt;ELSE&gt; ~FI</code>: renders the <code>&lt;ELSE&gt;</code> part when <code>&lt;CONDITION&gt;</code> evaluates to <em>0</em>, and renders the <code>&lt;THEN&gt;</code> in all other cases.
Valid <code>&lt;CONDITION&gt;</code>s are <code>~LENGTH[&lt;HOLE&gt;]</code>, <code>~SIZE[&lt;HOLE&gt;]</code>, <code>~CMPLE[&lt;HOLE1&gt;][&lt;HOLE2&gt;]</code>, <code>~DEPTH[&lt;HOLE&gt;]</code>, <code>~VIVADO</code>, <code>~IW64</code>, <code>~ISLIT[N]</code>, <code>~ISVAR[N]</code>, <code>~ISACTIVEENABLE[N]</code>, <code>~ISSYNC[N]</code>, and <code>~AND[&lt;HOLE1&gt;,&lt;HOLE2&gt;,..]</code>.</li>
<li><code>~VIVADO</code>: <em>1</em> when Clash compiler is invoked with the <code>-fclash-hdlsyn Vivado</code> (or <code>Xilinx</code> or <code>ISE</code>) flag.
To be used with in an <code>~IF .. ~THEN .. ~ELSE .. ~FI</code> statement.</li>
<li><code>~CMPLE[&lt;HOLE1&gt;][&lt;HOLE2&gt;]</code>: <em>1</em> when <code>&lt;HOLE1&gt; &lt;= &lt;HOLE2&gt;</code>, otherwise <em>0</em></li>
<li><code>~IW64</code>: <em>1</em> when <code>Int</code>/<code>Word</code>/<code>Integer</code> types are represented with 64 bits in HDL.
<em>0</em> when they're represented by 32 bits.</li>
<li><code>~TOBV[&lt;HOLE&gt;][&lt;TYPE&gt;]</code>: create conversion code that so that the expression in <code>&lt;HOLE&gt;</code> is converted to a bit vector (<code>std_logic_vector</code>).
The <code>&lt;TYPE&gt;</code> hole indicates the type of the expression and must be either <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~FROMBV[&lt;HOLE&gt;][&lt;TYPE&gt;]</code>: create conversion code that so that the expression in <code>&lt;HOLE&gt;</code>, which has a bit vector (<code>std_logic_vector</code>) type, is converted to type indicated by <code>&lt;TYPE&gt;</code>.
The <code>&lt;TYPE&gt;</code> hole must be either <code>~TYP[N]</code>, <code>~TYPO</code>, or <code>~TYPEL[&lt;HOLE&gt;]</code>.</li>
<li><code>~INCLUDENAME[N]</code>: the generated name of the <code>N</code>'th included component.</li>
<li><code>~FILE[&lt;HOLE&gt;]</code>: The argument mentioned in <code>&lt;HOLE&gt;</code> is a file which must be copied to the location of the generated HDL.</li>
<li><code>~GENERATE</code>: Verilog: create a <em>generate</em> statement, except when already in a <em>generate</em> context.</li>
<li><code>~ENDGENERATE</code>: Verilog: create an <em>endgenerate</em> statement, except when already in a <em>generate</em> context.</li>
<li><code>~ISLIT[N]</code>: Is the <code>(N+1)</code>'th argument to the function a literal.</li>
<li><code>~ISVAR[N]</code>: Is the <code>(N+1)</code>'th argument to the function explicitly not a literal.</li>
<li><code>~ISSCALAR[N]</code>: Is the <code>(N+1)</code>'th argument to the function a scalar.
Note that this means different things for different HDLs.
In (System)Verilog only <code>Bit</code> and <code>Bool</code> are considered scalar.
In VHDL, in addition to those two, enumeration types and integers are considered scalar.</li>
<li><code>~TAG[N]</code>: Name of given domain.
Errors when called on an argument which is not a <code>KnownDomain</code>, <code>Reset</code>, or <code>Clock</code>.</li>
<li><code>~PERIOD[N]</code>: Clock period of given domain.
Errors when called on an argument which is not a <code>Clock</code>, <code>Reset</code>, <code>KnownDomain</code> or <code>KnownConf</code>.</li>
<li><code>~ISACTIVEENABLE[N]</code>: Is the <code>(N+1)</code>'th argument an Enable line <strong>not</strong> set to a constant True.</li>
<li><code>~ISSYNC[N]</code>: Does synthesis domain at the <code>(N+1)</code>'th argument have synchronous resets.
Errors when called on an argument which is not a <code>Reset</code>, <code>Clock</code>, <code>Enable</code>, <code>KnownDomain</code> or <code>KnownConf</code>.</li>
<li><code>~ISINITDEFINED[N]</code>: Does synthesis domain at the <code>(N+1)</code>'th argument have defined initial values.
Errors when called on an argument which is not a <code>Clock</code>, <code>Reset</code>, <code>Enable</code>, <code>KnownDomain</code> or <code>KnownConf</code>.</li>
<li><code>~ACTIVEEDGE[edge][N]</code>: Does synthesis domain at the <code>(N+1)</code>'th argument respond to <em>edge</em>.
<em>edge</em> must be one of <code>Falling</code> or <code>Rising</code>.
Errors when called on an argument which is not a <code>Clock</code>, <code>Reset</code>, <code>Enable</code>, <code>KnownDomain</code> or <code>KnownConf</code>.</li>
<li><code>~AND[&lt;HOLE1&gt;,&lt;HOLE2&gt;,..]</code>: Logically <em>and</em> the conditions in the <code>&lt;HOLE&gt;</code>'s</li>
<li><code>~VAR[&lt;NAME&gt;][N]</code>: Like <code>~ARG[N]</code> but binds the argument to a variable named NAME.
The <code>&lt;NAME&gt;</code> can be left blank, then Clash will come up with a (unique) name.</li>
<li><code>~VARS[N]</code>: VHDL: Return the variables at the <code>(N+1)</code>'th argument.</li>
<li><code>~NAME[N]</code>: Render the <code>(N+1)</code>'th string literal argument as an identifier instead of a string literal.
Fails when the <code>(N+1)</code>'th argument is not a string literal.</li>
<li><code>~DEVNULL[&lt;HOLE&gt;]</code>: Render all dependencies of <code>&lt;HOLE&gt;</code>, but disregard direct output.</li>
<li><code>~REPEAT[&lt;HOLE&gt;][N]</code>: Repeat literal value of <code>&lt;HOLE&gt;</code> a total of <code>N</code> times.</li>
<li><code>~TEMPLATE[&lt;HOLE1&gt;][&lt;HOLE2&gt;]</code>: Render a file <code>&lt;HOLE1&gt;</code> with contents <code>&lt;HOLE2&gt;</code>.</li>
</ul>
<p>Some final remarks to end this section: HDL primitives are there to instruct the Clash compiler to use the given HDL template, instead of trying to do normal synthesis.
As a consequence you can use constructs inside the Haskell definitions that are normally not synthesizable by the Clash compiler.
However, VHDL primitives do not give us <em>co-simulation</em>, where you would be able to simulate VHDL and Haskell in a <em>single</em> environment.
If you still want to simulate your design in Haskell, you will have to describe, in a cycle- and bit-accurate way, the behavior of that (potentially complex) IP you are trying to include in your design.</p>
<h2 id="verilog-examples"><a class="header" href="#verilog-examples">Verilog examples</a></h2>
<p>For those who are interested, the equivalent Verilog primitives are:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Sized.Internal.Signed.*#
  kind: Expression
  type: '(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n'
  template: ~ARG[1] * ~ARG[2]
</code></pre>
<p>and</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Explicit.BlockRam.blockRam#
  kind: Declaration
  outputUsage: NonBlocking
  type: |-
    blockRam#
      :: ( KnownDomain dom        ARG[0]
         , HasCallStack  --       ARG[1]
         , NFDataX a )   --       ARG[2]
      =&gt; Clock dom       -- clk,  ARG[3]
      =&gt; Enable dom      -- en,   ARG[4]
      -&gt; Vec n a         -- init, ARG[5]
      -&gt; Signal dom Int  -- rd,   ARG[6]
      -&gt; Signal dom Bool -- wren, ARG[7]
      -&gt; Signal dom Int  -- wr,   ARG[8]
      -&gt; Signal dom a    -- din,  ARG[9]
      -&gt; Signal dom a
  template: |-
    // blockRam begin
    reg ~TYPO ~GENSYM[~RESULT_RAM][1] [0:~LENGTH[~TYP[5]]-1];
    reg ~TYP[5] ~GENSYM[ram_init][3];
    integer ~GENSYM[i][4];
    initial begin
      ~SYM[3] = ~CONST[5];
      for (~SYM[4]=0; ~SYM[4] &lt; ~LENGTH[~TYP[5]]; ~SYM[4] = ~SYM[4] + 1) begin
        ~SYM[1][~LENGTH[~TYP[5]]-1-~SYM[4]] = ~SYM[3][~SYM[4]*~SIZE[~TYPO]+:~SIZE[~TYPO]];
      end
    end
    ~IF ~ISACTIVEENABLE[4] ~THEN
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~GENSYM[~RESULT_blockRam][5]~IF ~VIVADO ~THEN
      if (~ARG[4]) begin
        if (~ARG[7]) begin
          ~SYM[1][~ARG[8]] &lt;= ~ARG[9];
        end
        ~RESULT &lt;= ~SYM[1][~ARG[6]];
      end~ELSE
      if (~ARG[7] &amp; ~ARG[4]) begin
        ~SYM[1][~ARG[8]] &lt;= ~ARG[9];
      end
      if (~ARG[4]) begin
        ~RESULT &lt;= ~SYM[1][~ARG[6]];
      end~FI
    end~ELSE
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~SYM[5]
      if (~ARG[7]) begin
        ~SYM[1][~ARG[8]] &lt;= ~ARG[9];
      end
      ~RESULT &lt;= ~SYM[1][~ARG[6]];
    end~FI
    // blockRam end
</code></pre>
<h2 id="systemverilog-examples"><a class="header" href="#systemverilog-examples">SystemVerilog examples</a></h2>
<p>And the equivalent SystemVerilog primitives are:</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Sized.Internal.Signed.*#
  kind: Expression
  type: '(*#) :: KnownNat n =&gt; Signed n -&gt; Signed n -&gt; Signed n'
  template: ~ARG[1] * ~ARG[2]
</code></pre>
<p>and</p>
<pre><code class="language-yaml">BlackBox:
  name: Clash.Explicit.BlockRam.blockRam#
  kind: Declaration
  type: |-
    blockRam#
      :: ( KnownDomain dom        ARG[0]
         , HasCallStack  --       ARG[1]
         , NFDataX a )   --       ARG[2]
      =&gt; Clock dom       -- clk,  ARG[3]
      -&gt; Enable dom      -- en,   ARG[4]
      -&gt; Vec n a         -- init, ARG[5]
      -&gt; Signal dom Int  -- rd,   ARG[6]
      -&gt; Signal dom Bool -- wren, ARG[7]
      -&gt; Signal dom Int  -- wr,   ARG[8]
      -&gt; Signal dom a    -- din,  ARG[9]
      -&gt; Signal dom a
  template: |-
    // blockRam begin
    ~SIGD[~GENSYM[RAM][1]][5];
    logic [~SIZE[~TYP[9]]-1:0] ~GENSYM[~RESULT_q][2];
    initial begin
      ~SYM[1] = ~CONST[5];
    end~IF ~ISACTIVEENABLE[4] ~THEN
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~GENSYM[~COMPNAME_blockRam][3]~IF ~VIVADO ~THEN
      if (~ARG[4]) begin
        if (~ARG[7]) begin
          ~SYM[1][~ARG[8]] &lt;= ~TOBV[~ARG[9]][~TYP[9]];
        end
        ~SYM[2] &lt;= ~SYM[1][~ARG[6]];
      end~ELSE
      if (~ARG[7] &amp; ~ARG[4]) begin
        ~SYM[1][~ARG[8]] &lt;= ~TOBV[~ARG[9]][~TYP[9]];
      end
      if (~ARG[4]) begin
        ~SYM[2] &lt;= ~SYM[1][~ARG[6]];
      end~FI
    end~ELSE
    always @(~IF~ACTIVEEDGE[Rising][0]~THENposedge~ELSEnegedge~FI ~ARG[3]) begin : ~SYM[3]
      if (~ARG[7]) begin
        ~SYM[1][~ARG[8]] &lt;= ~TOBV[~ARG[9]][~TYP[9]];
      end
      ~SYM[2] &lt;= ~SYM[1][~ARG[6]];
    end~FI
    assign ~RESULT = ~FROMBV[~SYM[2]][~TYP[9]];
    // blockRam end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>A list of often encountered errors and their solutions:</p>
<ul>
<li>
<p><strong>Type error: Couldn't match expected type <code>Signal dom (a,b)</code> with actual type <code>(Signal dom a, Signal dom b)</code></strong>:</p>
<p>Signals of product types and product types of signals are <strong>isomorphic</strong> due to synchronisity principle, but are not (structurally) equal.
Tuples are a product type.
Use the <code>bundle</code> function to convert from a product type to the signal type.
So if your code which gives the error looks like:</p>
<pre><code class="language-haskell">... = f a b (c,d)
</code></pre>
<p>add the <code>bundle</code> function like so:</p>
<pre><code class="language-haskell">... = f a b (bundle (c,d))
</code></pre>
<p>Product types supported by <code>bundle</code> are:</p>
<ul>
<li>All tuples up to and including 62-tuples (GHC limit)</li>
<li>The <code>Vec</code>tor type</li>
</ul>
</li>
<li>
<p><strong>Type error: Couldn't match expected type <code>(Signal dom a, Signal dom b)</code> with actual type <code>Signal dom (a,b)</code></strong>:</p>
<p>Product types of signals and signals of product types are <strong>isomorphic</strong> due to synchronicity principle, but are not (structurally) equal.
Tuples are a product type.
Use the <code>unbundle</code> function to convert from a signal type to the product type.
So if your code which gives the error looks like:</p>
<pre><code class="language-haskell">(c,d) = f a b
</code></pre>
<p>add the <code>unbundle</code> function like so:</p>
<pre><code class="language-haskell">(c,d) = unbundle (f a b)
</code></pre>
<p>Product types supported by <code>unbundle</code> are:</p>
<ul>
<li>All tuples up to and including 62-tuples (GHC limit)</li>
<li>The <code>Vec</code>tor type</li>
</ul>
</li>
<li>
<p><strong>Clash.Netlist(..): Not in normal form: &lt;REASON&gt;: &lt;EXPR&gt;</strong>:</p>
<p>A function could not be transformed into the expected normal form.
This usually means one of the following:</p>
<ul>
<li>The <code>topEntity</code> has higher-order arguments, or a higher-order result.</li>
<li>You are using types which cannot be represented in hardware.</li>
</ul>
<p>The solution for all the above listed reasons is quite simple: remove them.
That is, make sure that the <code>topEntity</code> is completely monomorphic and first-order.
Also remove any variables and constants/literals that have a non-representable type; see <a href="developing-hardware/limitations.html">Limitations of Clash</a> to find out which types are not representable.</p>
</li>
<li>
<p><strong>Clash.Normalize(..): Clash can only normalize monomorphic functions, but this is polymorphic</strong>:</p>
<p>If this happens for a <code>topEntity</code> or something with a <code>Synthesize</code> annotation, add a monomorphic type signature.
Non topEntites should be type-specialized by clash automatically, if not please report this as a bug.
But adding a monomorphic type signature should still help (when possible).</p>
</li>
<li>
<p><strong>Clash.Normalize(..): Expr belonging to bndr: &lt;FUNCTION&gt; remains recursive after normalization</strong>:</p>
<ul>
<li>
<p>If you actually wrote a recursive function, rewrite it to a non-recursive one using e.g. one of the higher-order functions in <code>Clash.Sized.Vector</code></p>
</li>
<li>
<p>You defined a recursively defined value, but left it polymorphic:</p>
</li>
</ul>
<pre><code class="language-haskell">topEntity x y = acc
  where
    acc = register 3 (acc + x * y)
</code></pre>
<p>The above function, works for any number-like type.
This means that <code>acc</code> is a recursively defined <strong>polymorphic</strong> value.
Adding a monomorphic type annotation makes the error go away:</p>
<pre><code class="language-haskell">topEntity
  :: SystemClockResetEnable
  =&gt; Signal System (Signed 8)
  -&gt; Signal System (Signed 8)
  -&gt; Signal System (Signed 8)
topEntity x y = acc
  where
    acc = register 3 (acc + x * y)
</code></pre>
</li>
<li>
<p><strong>Clash.Normalize.Transformations(..): InlineNonRep: &lt;FUNCTION&gt; already inlined 100 times in:&lt;FUNCTION&gt;, &lt;TYPE&gt;</strong>:</p>
<p>You left the <code>topEntity</code> function polymorphic or higher-order: use <code>:i topEntity</code> to check if the type is indeed polymorphic or higher-order.
If it is, add a monomorphic type signature, and/or supply higher-order arguments.</p>
</li>
<li>
<p><strong>&lt;*** Exception: &lt;&lt;loop&gt;&gt; or "blinking cursor"</strong></p>
<p>You are using value-recursion, but one of the <code>Vec</code>tor functions that you are using is too <em>strict</em> in one of the recursive arguments.
For example:</p>
<pre><code class="language-haskell">-- Bubble sort for 1 iteration
sortV xs = map fst sorted :&lt; (snd (last sorted))
 where
   lefts  = head xs :&gt; map snd (init sorted)
   rights = tail xs
   sorted = zipWith compareSwapL lefts rights

-- Compare and swap
compareSwapL a b = if a &lt; b then (a,b) else (b,a)
</code></pre>
<p>Will not terminate because <code>zipWith</code> is too strict in its second argument.</p>
<p>In this case, adding <code>lazyV</code> on <code>zipWith</code>s second argument:</p>
<pre><code class="language-haskell">sortVL xs = map fst sorted :&lt; (snd (last sorted))
 where
   lefts  = head xs :&gt; map snd (init sorted)
   rights = tail xs
   sorted = zipWith compareSwapL (lazyV lefts) rights
</code></pre>
<p>Results in a successful computation:</p>
<pre><code>clashi&gt; sortVL (4 :&gt; 1 :&gt; 2 :&gt; 3 :&gt; Nil)
1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; Nil
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-of-the-compiler"><a class="header" href="#limitations-of-the-compiler">Limitations of the compiler</a></h1>
<p>Here is a list of Haskell features for which the Clash compiler has only <em>limited</em> support (for now):</p>
<ul>
<li>
<p><strong>Recursively defined functions</strong></p>
<p>At first hand, it seems rather bad that a compiler for a functional language cannot synthesize recursively defined functions to circuits.
However, when viewing your functions as a <em>structural</em> specification of a circuit, this <em>feature</em> of the Clash compiler makes sense.
Also, only certain types of recursion are considered non-synthesizable; recursively defined values are for example synthesizable: they are (often) synthesized to feedback loops.</p>
<p>Let us distinguish between three variants of recursion:</p>
<ul>
<li>
<p><strong>Dynamic data-dependent recursion</strong></p>
<p>As demonstrated in this definition of a function that calculates the n'th Fibbonacci number:</p>
<pre><code class="language-haskell">fibR 0 = 0
fibR 1 = 1
fibR n = fibR (n-1) + fibR (n-2)
</code></pre>
<p>To get the first 10 numbers, we do the following:</p>
<pre><code>&gt;&gt;&gt; import qualified Data.List as L
&gt;&gt;&gt; L.map fibR [0..9]
[0,1,1,2,3,5,8,13,21,34]
</code></pre>
<p>The <code>fibR</code> function is not synthesizable by the Clash compiler, because, when we take a <em>structural</em> view, <code>fibR</code> describes an infinitely deep structure.</p>
<p>In principle, descriptions like the above could be synthesized to a circuit, but it would have to be a <em>sequential</em> circuit.
Where the most general synthesis would then require a stack.
Such a synthesis approach is also known as <em>behavioral</em> synthesis, something which the Clash compiler simply does not do.
One reason that Clash does not do this is because it does not fit the paradigm that only functions working on values of type <code>Signal</code> result in sequential circuits, and all other (non higher-order) functions result in combinational circuits.
This paradigm gives the designer the most straightforward mapping from the original Haskell description to generated circuit, and thus the greatest control over the eventual size of the circuit and longest propagation delay.</p>
</li>
<li>
<p><strong>Value-recursion</strong></p>
<p>As demonstrated in this definition of a function that calculates the n'th Fibbonaci number on the n'th clock cycle:</p>
<pre><code class="language-haskell">fibS :: SystemClockResetEnable =&gt; Signal System (Unsigned 64)
fibS = r
    where r = register 0 r + register 0 (register 1 r)
</code></pre>
<p>To get the first 10 numbers, we do the following:</p>
<pre><code>&gt;&gt;&gt; sampleN @System 11 fibS
[0,0,1,1,2,3,5,8,13,21,34]
</code></pre>
<p>Unlike the <code>fibR</code> function, the above <code>fibS</code> function <em>is</em> synthesizable by the Clash compiler.
Where the recursively defined (non-function) value <em>r</em> is synthesized to a feedback loop containing three registers and one adder.</p>
<p>Note that not all recursively defined values result in a feedback loop.
An example that uses recursively defined values which does not result in a feedback loop is the following function that performs one iteration of bubble sort:</p>
<pre><code class="language-haskell">sortV xs = map fst sorted :&lt; (snd (last sorted))
  where
    lefts  = head xs :&gt; map snd (init sorted)
    rights = tail xs
    sorted = zipWith compareAndSwap (lazyV lefts) rights

compareAndSwap a b = if a &lt; b then (a,b) else (b,a)
</code></pre>
<p>Where we can clearly see that <code>lefts</code> and <code>sorted</code> are defined in terms of each other.
Also the above <code>sortV</code> function <em>is</em> synthesizable.</p>
</li>
<li>
<p><strong>Static/Structure-dependent recursion</strong></p>
<p>Static, or, structure-dependent recursion is a rather <em>vague</em> concept.
What we mean by this concept are recursive definitions where a user can sensibly imagine that the recursive definition can be completely unfolded (all recursion is eliminated) at compile-time in a finite amount of time.</p>
<p>Such definitions would e.g. be:</p>
<pre><code class="language-haskell">mapV :: (a -&gt; b) -&gt; Vec n a -&gt; Vec n b
mapV _ Nil         = Nil
mapV f (Cons x xs) = Cons (f x) (mapV f xs)

topEntity :: Vec 4 Int -&gt; Vec 4 Int
topEntity = mapV (+1)
</code></pre>
<p>Where one can imagine that a compiler can unroll the definition of <code>mapV</code> four times, knowing that the <code>topEntity</code> function applies <code>mapV</code> to a <code>Vec</code> of length 4.
Sadly, the compile-time evaluation mechanisms in the Clash compiler are very poor, and a user-defined function such as the <code>mapV</code> function defined above, is <em>currently</em> not synthesizable.
We <em>do</em> plan to add support for this in the future.
In the mean time, this poor support for user-defined recursive functions is amortized by the fact that the Clash compiler has built-in support for the higher-order functions defined in <code>Clash.Sized.Vector</code>.
Most regular design patterns often encountered in circuit design are captured by the higher-order functions in <code>Clash.Sized.Vector</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Recursive datatypes</strong></p>
<p>The Clash compiler needs to be able to determine a bit-size for any value that will be represented in the eventual circuit.
More specifically, we need to know the maximum number of bits needed to represent a value.
While this is trivial for values of the elementary types, sum types, and product types, putting a fixed upper bound on recursive types is not (always) feasible.
This means that the ubiquitous list type is unsupported!
The only recursive types that are currently supported by the Clash compiler is the <code>Vec</code>tor and <code>RTree</code> types, for which the compiler has hard-coded knowledge.</p>
<p>For "easy" <code>Vec</code>tor literals you should use Template Haskell splices and the <code>listToVecTH</code> <em>meta</em>-function.</p>
</li>
<li>
<p><strong>GADTs</strong></p>
<p>Clash has experimental support for GADTs.
Similar to recursive types, Clash cannot determine bit-sizes of GADTs.
Notable exceptions to this rule are <code>Vec</code> and <code>RTree</code>.
You can still use your own GADTs, as long as they can be removed through static analysis.
For example, the following case will be optimized away and is therefore fine to use:</p>
<pre><code class="language-haskell">x =
  case resetKind @System of
    SAsynchronous -&gt; 'a'
    SSynchronous -&gt; 'b'
</code></pre>
</li>
<li>
<p><strong>Floating point types</strong></p>
<p>There is no support for the <code>Float</code> and <code>Double</code> types, if you need numbers with a <em>fractional</em> part you can use the <code>Fixed</code> point type.</p>
<p>As to why there is no support for these floating point types:</p>
<ol>
<li>
<p>In order to achieve reasonable operating frequencies, arithmetic circuits for floating point data types must be pipelined.</p>
</li>
<li>
<p>Haskell's primitive arithmetic operators on floating point data types, such as <code>plusFloat#</code></p>
<pre><code class="language-haskell">plusFloat# :: Float# -&gt; Float# -&gt; Float#
</code></pre>
<p>which underlie <code>Float</code>'s <code>Num</code> instance, must be implemented as purely combinational circuits according to their type.
Remember, sequential circuits operate on values of type <code>Signal dom a</code>.</p>
</li>
</ol>
<p>Although it is possible to implement purely combinational (not pipelined) arithmetic circuits for floating point data types, the circuit would be unreasonable slow.
So, without synthesis possibilities for the basic arithmetic operations, there is no point in supporting the floating point data types.</p>
</li>
<li>
<p><strong>Haskell primitive types</strong></p>
<p>Only the following primitive Haskell types are supported:</p>
<ul>
<li><code>Integer</code></li>
<li><code>Int</code></li>
<li><code>Int8</code></li>
<li><code>Int16</code></li>
<li><code>Int32</code></li>
<li><code>Int64</code> (not available when compiling with <code>-fclash-intwidth=32</code> on a 64-bit machine)</li>
<li><code>Word</code></li>
<li><code>Word8</code></li>
<li><code>Word16</code></li>
<li><code>Word32</code></li>
<li><code>Word64</code> (not available when compiling with <code>-fclash-intwidth=32</code> on a 64-bit machine)</li>
<li><code>Char</code></li>
</ul>
<p>There are several aspects of which you should take note:</p>
<ul>
<li>
<p><code>Int</code> and <code>Word</code> are represented by the same number of bits as is native for the architecture of the computer on which the Clash compiler is executed.
This means that if you are working on a 64-bit machine, <code>Int</code> and <code>Word</code> will be 64-bit.
This might be problematic when you are working in a team, and one designer has a 32-bit machine, and the other has a 64-bit machine.
In general, you should be avoiding <code>Int</code> in such cases, but as a band-aid solution, you can force the Clash compiler to use a specific bit-width for <code>Int</code> and <code>Word</code> using the <code>-fclash-intwidth=N</code> flag, where <em>N</em> must either be <em>32</em> or <em>64</em>.</p>
</li>
<li>
<p>When you use the <code>-fclash-intwidth=32</code> flag on a <em>64-bit</em> machine, the <code>Word64</code> and <code>Int64</code> types <em>cannot</em> be translated. This restriction does <em>not</em> apply to the other three combinations of <code>-fclash-intwidth</code> flag and machine type.</p>
</li>
<li>
<p>The translation of <code>Integer</code> is not meaning-preserving.
<code>Integer</code> in Haskell is an arbitrary precision integer, something that cannot be represented in a statically known number of bits.
In the Clash compiler, we chose to represent <code>Integer</code> by the same number of bits as we do for <code>Int</code> and <code>Word</code>.
As you have read in a previous bullet point, this number of bits is either 32 or 64, depending on the architecture of the machine the Clash compiler is running on, or the setting of the <code>-fclash-intwidth</code> flag.</p>
<p>Consequently, you should use <code>Integer</code> with due diligence; be especially careful when using <code>fromIntegral</code> as it does a conversion via <code>Integer</code>.
For example:</p>
<pre><code class="language-haskell">signedToUnsigned :: Signed 128 -&gt; Unsigned 128
signedToUnsigned = fromIntegral
</code></pre>
<p>can either lose the top 64 or 96 bits depending on whether <code>Integer</code> is represented by 64 or 32 bits.
Instead, when doing such conversions, you should use <code>bitCoerce</code>:</p>
<pre><code class="language-haskell">signedToUnsigned :: Signed 128 -&gt; Unsigned 128
signedToUnsigned = bitCoerce
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Side-effects: <code>IO</code>, <code>ST</code>, etc.</strong></p>
<p>There is no support for side-effecting computations such as those in the <code>IO</code> or <code>ST</code> monad.
There is also no support for Haskell's <a href="http://www.haskell.org/haskellwiki/Foreign_Function_Interface">FFI</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hacking-on-the-clash-compiler"><a class="header" href="#hacking-on-the-clash-compiler">Hacking on the Clash Compiler</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Hacking on Clash requires more dependencies than simply running Clash.
The test suite requires having a tool available to synthesize any backend being tested.
This means you need:</p>
<ul>
<li><a href="https://github.com/ghdl/ghdl">ghdl</a> installed to test <em>VHDL</em></li>
<li><a href="https://github.com/steveicarus/iverilog">iverilog</a> installed to test <em>Verilog</em></li>
<li><a href="http://verilator.org/">Verilator</a> installed to test <em>Verilog</em> and <em>SystemVerilog</em></li>
<li><a href="https://fpgasoftware.intel.com/?product=modelsim_ae#tabs-2">ModelSim</a> installed to test <em>SystemVerilog</em></li>
<li><a href="https://www.amd.com/en/products/software/adaptive-socs-and-fpgas/vivado.html">Vivado</a> installed to test <em>VHDL</em>, <em>Verilog</em> and <em>SystemVerilog</em></li>
<li><a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a> and <a href="https://github.com/Z3Prover/z3">Z3</a> installed to test <em>Verilog</em> and <em>SystemVerilog</em></li>
</ul>
<h2 id="get-clash-from-source"><a class="header" href="#get-clash-from-source">Get Clash from source</a></h2>
<p>Get the source code using <a href="https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F">Git</a> and enter the cloned directory:</p>
<pre><code class="language-bash">git clone git@github.com:clash-lang/clash-compiler.git

# Alternatively, if you haven't setup SSH keys with GitHub:
# git clone https://github.com/clash-lang/clash-compiler.git

cd clash-compiler
</code></pre>
<p>To check out a released version, use:</p>
<pre><code class="language-bash">git checkout v1.2.3
</code></pre>
<p>To checkout a release <em>branch</em> use:</p>
<pre><code class="language-bash">git checkout 1.2
</code></pre>
<p>Note that release branches might contain non-released patches.</p>
<h3 id="cabal"><a class="header" href="#cabal">Cabal</a></h3>
<p>To use Cabal you need both Cabal and GHC installed on your system.
For Linux and MacOS users we recommend using <a href="https://www.haskell.org/ghcup/">ghcup</a>.
Windows users are recommended to use the <a href="https://www.haskell.org/platform/windows.html">Haskell Platform</a>.</p>
<p>To run <span class="title-ref">clash</span> use:</p>
<pre><code class="language-bash">cabal v2-run -- clash
</code></pre>
<p>If this fails, make sure you've got an up-to-date package index:</p>
<pre><code class="language-bash">cabal update
</code></pre>
<h3 id="stack"><a class="header" href="#stack">Stack</a></h3>
<p><a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/">Install Stack</a> and run:</p>
<pre><code class="language-bash">stack run -- clash
</code></pre>
<h3 id="nix"><a class="header" href="#nix">Nix</a></h3>
<p>Or <a href="https://nixos.org/nix/download.html">use Nix</a> to get a shell with the <code>clash</code> and <code>clashi</code> binaries on your PATH:</p>
<pre><code class="language-bash">nix develop
</code></pre>
<h2 id="subprojects"><a class="header" href="#subprojects">Subprojects</a></h2>
<p>The Clash compiler consists of different cabal libraries, which together provide a complete compiler.
Primarily, this consists of</p>
<p><code>clash-ghc</code></p>
<blockquote>
<p>The frontend of the compiler, using parts of the GHC frontend.
This provides the ability to load modules, translate GHC Core to Clash Core, and implements the <code>clash</code> and <code>clashi</code> executables.</p>
<p>A lot of the code in this library is separated by the version of GHC it works with.
For example, <code>src-bin-9.0</code> is specific to GHC 9.0.x.</p>
</blockquote>
<p><code>clash-lib</code></p>
<blockquote>
<p>The backend of the compiler, exposed as a library.
This is the largest library in the project, and includes the various ASTs (e.g. Core, Netlist), normalization, code generation, and primitives / black boxes.</p>
</blockquote>
<p><code>clash-prelude</code></p>
<blockquote>
<p>The standard library for Clash as a language.
This includes anything that is used to develop hardware in Clash, such as Signals, Clocks and combinators for common forms of state machine.</p>
<p>The <code>clash-prelude</code> library also re-exports parts of the Haskell <code>base</code> library, allowing circuit designs to reuse common functions and definitions.</p>
</blockquote>
<p>The repository also contains other libraries.
These either provide additional functionality which is not required, or are not yet production-ready.
These are</p>
<p><code>clash-cosim</code></p>
<blockquote>
<p>Co-simulation for Clash, allowing Verilog to be run inline as though it were a normal Haskell function.
This provides a QuasiQuoter for use in Haskell.</p>
<div class="warning">
<div class="title">
<p>Warning</p>
</div>
<p>This library is very experimental, and is not guaranteed to work with the most recent development version of Clash.</p>
</div>
</blockquote>
<p><code>clash-term</code></p>
<blockquote>
<p>A development tool for analyzing how the normalizer in <code>clash-lib</code> affects the core of a particular design.
It allows the result of each different optimizer pass to be seen for debugging purposes.</p>
</blockquote>
<p><code>clash-lib-hedgehog</code></p>
<blockquote>
<p>Hedgehog Generators for <code>clash-lib</code>.</p>
</blockquote>
<p><code>clash-prelude-hedgehog</code></p>
<blockquote>
<p>Hedgehog Generators for <code>clash-prelude</code>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
