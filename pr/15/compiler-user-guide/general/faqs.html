<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FAQs - Clash Compiler User Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clash Compiler User Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="basic-questions"><a class="header" href="#basic-questions">Basic Questions</a></h2>
<ul>
<li>
<p><strong>Q</strong>: How do I install Clash?</p>
<p><strong>A</strong>: Check out <a href="https://clash-lang.org/install">clash-lang.org/install</a> to install the latest stable release of Clash, or to setup a Clash project.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Is the name "Clash", "CLaSH", or "CλaSH"?</p>
<p><strong>A</strong>: It's <strong>Clash</strong>.</p>
<p>In its research stages Clash was called "CλaSH", an acronym for the <strong>C</strong>AES <strong>La</strong>nguage for <strong>S</strong>ynchronous <strong>H</strong>ardware.
CAES is a group of the Faculty of Electrical Engineering, Mathematics and Computer Science at the University of Twente.
Clash was originally developed by Christaan Baaij and supervisor Jan Kuper.
The stylization "CλaSH" is an homage to <a href="https://haskell.org">Haskell</a>, whose official logo has long been the venerable Greek <em>lambda</em> character.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Is Clash a "high-level synthesis" tool?</p>
<p><strong>A</strong>: While clash provides high-level language features, hardware descriptions written in Clash are not decoupled from clock-level timing.
Clash does therefore not offer what is generally understood as "high-level synthesis".
Compared to the big three hardware description languages, <em>VHDL</em>, <em>Verilog</em>, and <em>SystemVerilog</em>, Clash arguably <em>is</em> high-level.
It offers many of the powerful abstractions that modern software programming languages offer.
In fact, it inherits many of the software industry's bleeding-edge features by virtue of basing its implementation on Haskell.</p>
</li>
</ul>
<h2 id="clash-support"><a class="header" href="#clash-support">Clash Support</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Is Clash production ready?</p>
<p><strong>A</strong>: Clash is constantly evolving, and since the 1.0 release there is a focus on maintaining API backwards compatibility.
Clash is used successfully in real-world scenarios, and <a href="https://qbaylogic.com/services/">QBayLogic Clash support</a> can help with education and implementation of Clash projects.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Will Clash work with my EDA tools?</p>
<p><strong>A</strong>: In general, Clash should work well with Xilinx and Intel FPAGs and their EDA tools — as development typically focuses on these vendors.
Clash has also been successfully used on Microsemi (formerly Actel) SmartFusion 2 and Lattice Semiconductor iCE40 FPGAs, and some basic IP for these exist.</p>
<p>For most toolchains, the default primitives supplied by Clash should work with minimal effort.
If not, it is possible to call your vendor's library manually, or use a tool like <a href="http://clifford.at/yosys">Yosys</a> to do mapping.
It is also possible to consult <a href="https://qbaylogic.com/services/">QBayLogic Clash support</a> for more assistance.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Does Clash support <a href="http://clifford.at/icestorm">Project IceStorm</a>?</p>
<p><strong>A</strong>: The Verilog backend for Clash emits Verilog 2001, which is supported by <a href="http://clifford.at/yosys">Yosys</a>.
This means it can be placed and packed with <em>arachne-pnr</em> and <em>icestorm</em>.
Additionally, Clash has some support for the Lattice Semiconductor iCE40 FPGA.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Can Clash be used for ASIC designs, as well as FPGA designs?</p>
<p>Clash can be used for ASIC designs, however the RTL produced by Clash may not be immediately suitable as it is largely platform agnostic.
While this is not a problem for FPGAs, it can make developing ASICs more complicated as many ASIC vendors have different proprietary tool flows, with limited information available about their workings.</p>
<p>If you are using Clash to develop for ASIC, and need assistance with getting your toolchain to work, you can contact <a href="https://qbaylogic.com/services/">QBayLogic Clash support</a> for assistance.</p>
</li>
</ul>
<h2 id="clash-and-haskell"><a class="header" href="#clash-and-haskell">Clash and Haskell</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Is Clash its own programming language, or is it Haskell?</p>
<p><strong>A</strong>: Clash is a programming language in its own right, complete with its own executable and standard library.
Clash is also related to the Haskell programming language, and may be thought of as a dialect of Haskell for developing hardware.
While the surface syntax and typing rules are the same, the semantics change as code progresses through the compilation pipeline.</p>
<p>Due to the shared behavior in the early stages of the compiler, components from GHC (the most common Haskell compiler) are reused in the Clash compiler.
This is how Clash achieves such high interoperability with existing Haskell projects.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Clash has better inference for type level natural numbers than GHC.
How is this possible?</p>
<p><strong>A</strong>: Clash's enhanced type checking functionality is due to the use of GHC compiler plugins, which can be used in any Haskell project.
To enable these plugins, pass the following compiler flags to GHC:</p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise       #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Extra.Solver    #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
</code></pre>
<p>These plugins come from the <code>ghc-typelits-natnormalise</code>, <code>ghc-typelits-extra</code>, and <code>ghc-typelits-knownnat</code> packages respectively, which are all available from Hackage and Stackage.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: Do I need to know Haskell in order to use Clash?</p>
<p><strong>A</strong>: As Clash is deeply integrated with Haskell, it is recommended that users have some familiarity with Haskell, or functional programming in general.
Clash uses some advanced features of Haskell, and real-world designs will often want to leverage the existing Haskell ecosystem.</p>
<p>For developers who are particularly familiar with either Haskell or hardware design, Clash should be relatively intuitive to use.
Additionally, obvious mistakes with designs will be identified and reported due to the strong type system identifying mistakes at compile-time.</p>
</li>
</ul>
<h2 id="clash-and-other-hdls"><a class="header" href="#clash-and-other-hdls">Clash and other HDLs</a></h2>
<ul>
<li>
<p><strong>Q</strong>: Do I need to know existing RTL/HDL languages in order to use Clash?</p>
<p><strong>A</strong>: Clash currently outputs VHDL, Verilog, and SystemVerilog.
While it's not necessary to understand these descriptions, you will need to some understanding of vendor tools to actually deploy it.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: What's the difference between Clash and Lava?</p>
<p><strong>A</strong>: Lava dialects (including the modern variant <a href="https://github.com/mn416/blarney">Blarney</a>) are all embedded domain specific languages (EDSLs) inside Haskell.
On top of that they use a so-called <em>deep</em> embedding to be able to transform a circuit description into a netlist (to subsequently output that as a VHDL/Verilog file).
Clash on the other hand uses "standard" compiler techniques to create a netlist from the Haskell abstract syntax tree (AST).
This "standard" compiler technique enables the following features not available in (Haskell-based) EDSLs:</p>
<blockquote>
<ol>
<li>Clash allows the use of normal Haskell operations such as (==) on both the meta-level (how the program is structured/generated), and the object-level (the functionality of the program).</li>
<li>Clash allows the use of regular Haskell syntax to model the concept of 'choice' at the object-level (the functionality of the program): if-expressions, guards, case, etc.</li>
<li>Clash allows programmers to use native Haskell pattern matching.</li>
</ol>
</blockquote>
<p>Basically, with Clash you can use regular Haskell to describe the behavior of the circuit, most importantly all of it's choice-constructs (case-expressions, guards, etc.).
With an EDSL you are "limited" by the constructs of the DSL, making your circuit descriptions look less like regular Haskell functions.</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><strong>Q</strong>: What's the difference between Clash and Chisel/Spinal/Migen/Hardcaml?</p>
<p><strong>A</strong>: The biggest difference between these toolchains and Clash is that Clash exists as a Haskell derivative, with a full synthesizing compiler to RTL — while Chisel/Spinal/Migen/Hardcaml exists as an embedding of hardware semantics inside Scala/Scala/Python/OCaml.
Aside from the "host language" differences, this means that Chisel/Spinal/Migen/Hardcaml are conceptually closer to something like Lava/Blarney than to Clash.
So within these languages you can only use the host language constructs to structure and compose the constructs of the EDSL, and you can't use host language constructs to describe the behavior of the circuit; i.e. you cannot use the host language's regular if-expression to model the concept of choice, but you have to use e.g. Chisel's <em>when</em>-function.</p>
<p>Aside from the above, there is also a varying degree of <em>native</em> simulation and interactivity.
In Clash you can evaluate/simulate any (sub-)component in the interactive interpreter for an immediate and localized design feedback loop.
The only EDSLs that have a similar interactive interpreter for fast design feedback are the older variants of Lava.
They used a so-called dual-embedding, where the EDSL primitives also contained a normal Haskell function which described their behavior, and so the composition of these primitives could be evaluated as a regular Haskell function.</p>
<p>The other EDSLs all offer simulation, but there is a higher latency to get from a design to a simulation of a design, and they are not as interactive.
Blarney emits Verilog, and you can then use a Verilog simulator to simulate the Blarney design.
Spinal also emits Verilog, but it then uses Verilator to compile it to an object-file which is loaded back into Scala, allowing you to interact with your Spinal design from within Scala.
Chisel is also not interpreted directly, instead, a Chisel description is "lowered" to FIRRTL where that FIRRTL description is then executed inside Scala by the FIRRTL interpreter.
Migen works similarly to Chisel as far as the approach to simulation goes, although perhaps more direct: it directly interprets its own deep embedding data structure (its <em>IR</em>) to enable native simulation.</p>
<p>All of this influences the style in which you write circuits and the creative process by which you come to a solution; the effects of this on the quality of results (QoR) and development time are, however, both hard to qualify and hard to quantify.
That is, although all of these languages, both the EDSLs and Clash, enable full control over the QoR (i.e. you can get as many registers and as much logic as you intended), the way in which you get there can vary from problem domain to problem domain and person to person.
If you have enough time, we encourage to try several of them and see which style is the most natural fit for you; if you're limited on time, we of course recommend that you just go with Clash ;-)</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../general/relnotes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../general/license.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../general/relnotes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../general/license.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
