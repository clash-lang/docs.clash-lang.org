<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clash Tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clash Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="clash-language-tutorial"><a class="header" href="#clash-language-tutorial">Clash Language Tutorial</a></h1>
<p>Welcome to the Clash Language Tutorial, part of the official documentation of the <a href="https://clash-lang.org">Clash Compiler</a>.
Clash is an open-source functional hardware description language (HDL) that borrows syntax and semantics from the <a href="https://www.haskell.org">Haskell</a> programming language.
To learn more about the language, we suggest reading the <a href="./intro.html">introduction</a>.</p>
<p>The table of contents below (and in the sidebar) allows easy access to different pages in the documentation.
You can also use the search function in the top left corner.</p>
<div class="note">
<div class="title">
<p>Note</p>
</div>
<p>The Clash Compiler and the Clash Language Tutorial are open-source efforts developed by QBayLogic B.V. and other volunteers.
The Clash Team always appreciates feedback and contributions to the project to help improve the development experience.</p>
<p>If you do not understand something, or think something is missing or incorrect in the documentation you can open an issue or pull request in the <a href="https://github.com/clash-lang/docs.clash-lang.org">GitHub repository</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Clash is a functional hardware description language that borrows both its syntax and semantics from the functional programming language Haskell.
It provides a familiar structural design approach to both combinational and synchronous sequential circuits.</p>
<p>Features of the Clash language:</p>
<ul>
<li>Strongly typed, but with a very high degree of type inference, enabling both safe and fast prototyping using concise descriptions.</li>
<li>Interactive <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>: load your designs in an interpreter and easily test all your components without needing to set up a test bench.</li>
<li>Higher-order functions, in combination with type inference, result in designs that are fully parametric by default.</li>
<li>Synchronous sequential circuit design based on streams of values, called <code>Signal</code>s, leads to natural descriptions of feedback loops.</li>
<li>Multiple clock domains, with type-safe clock domain crossing.</li>
</ul>
<p>Although we say that Clash borrows the semantics of Haskell, that statement should be taken with a grain of salt.
What we mean to say is that the Clash compiler views a circuit description as a <em>structural</em> description.
This means, in an academically handwavy way, that every function denotes a component and every function application denotes an instantiation of said component.
Now, this has consequences on how we view <em>recursively</em> defined functions: structurally, a recursively defined function would denote an <em>infinitely</em> deeply structured component, something that cannot be turned into an actual circuit.</p>
<p>On the other hand, Haskell's by-default non-strict evaluation works very well for the simulation of feedback loops, which are ubiquitous in digital circuits.
That is, when we take a structural view on circuit descriptions, value recursion corresponds directly to a feedback loop:</p>
<pre><code class="language-haskell">counter = s
 where
  s = register 0 (s + 1)
</code></pre>
<p>The above definition, which uses value recursion, <em>can</em> be synthesized to a circuit by the Clash compiler.</p>
<p>Over time, you will get a better feeling for the consequences of taking a <em>structural</em> view on circuit descriptions.
What is always important to remember is that every applied function results in an instantiated component, and also that the compiler will <em>never</em> infer/invent more logic than what is specified in the circuit description.</p>
<p>With that out of the way, let us continue with installing Clash and building our first circuit.</p>
<h2 id="installing-clash"><a class="header" href="#installing-clash">Installing Clash</a></h2>
<p>For installation instructions, see <a href="https://clash-lang.org/install/">clash-lang.org/install/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-this-tutorial"><a class="header" href="#working-with-this-tutorial">Working with this tutorial</a></h1>
<p>This tutorial can be followed best whilst having the Clash interpreter running at the same time.
If you followed the <a href="https://clash-lang.org/install/">instructions</a> to setup a starter project with Stack, you can also run <code>clashi</code> inside such a project.
Change to the directory of the project, and invoke</p>
<pre><code>stack run -- clashi
</code></pre>
<p>If you instead set up the starter project with GHC and Cabal, change to the directory of the project and invoke</p>
<pre><code>cabal run -- clashi
</code></pre>
<p>If you instead followed the instructions under <em>Run Clash on its own</em>, you can start the Clash compiler in interpretive mode by:</p>
<pre><code>stack exec --resolver lts-23.15 --package clash-ghc -- clashi
</code></pre>
<p>For those familiar with Haskell/GHC, this is indeed just <code>GHCi</code>, with three added commands (<code>:vhdl</code>, <code>:verilog</code>, and <code>:systemverilog</code>).
You can load files into the interpreter using the <code>:l &lt;FILENAME&gt;</code> command.
Now, depending on your choice in editor, the following <code>edit-load-run</code> cycle probably work best for you:</p>
<ul>
<li>
<p><strong>Commandline (e.g. emacs, vim):</strong></p>
<ul>
<li>You can run system commands using <code>:!</code>, for example <code>:! touch &lt;FILENAME&gt;</code></li>
<li>Set the /editor/ mode to your favourite editor using: <code>:set editor &lt;EDITOR&gt;</code></li>
<li>You can load files using <code>:l</code> as noted above.</li>
<li>You can go into /editor/ mode using: <code>:e</code></li>
<li>Leave the editor mode by quitting the editor (e.g. <code>:wq</code> in <code>vim</code>)</li>
</ul>
</li>
<li>
<p><strong>GUI (e.g. SublimeText, Notepad++):</strong></p>
<ul>
<li>Just create new files in your editor.</li>
<li>Load the files using <code>:l</code> as noted above.</li>
<li>Once a file has been edited and saved, type <code>:r</code> to reload the files in the interpreter</li>
</ul>
</li>
</ul>
<p>You are of course free to deviate from these suggestions as you see fit :-).
It is just recommended that you have the Clash interpreter open during this tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-circuit"><a class="header" href="#your-first-circuit">Your first circuit</a></h1>
<p>The very first circuit that we will build is the "classic" multiply-and-accumulate (MAC) circuit.
This circuit is as simple as it sounds, it multiplies its inputs and accumulates them.
Before we describe any logic, we must first create the file we will be working on and input some preliminaries:</p>
<ul>
<li>
<p>Create the file:</p>
<pre><code>MAC.hs
</code></pre>
</li>
<li>
<p>Write on the first line the module header:</p>
<pre><code class="language-haskell">module MAC where
</code></pre>
<p>Module names must always start with a <strong>C</strong>apital letter.
Also make sure that the file name corresponds to the module name.</p>
</li>
<li>
<p>Add the import statement for the Clash prelude library:</p>
<pre><code class="language-haskell">import Clash.Prelude
</code></pre>
<p>This imports all the necessary functions and datatypes for circuit description.</p>
</li>
</ul>
<p>We can now finally start describing the logic of our circuit, starting with just the multiplication and addition:</p>
<pre><code class="language-haskell">ma acc (x, y) = acc + x * y
</code></pre>
<p>The circuit we just wrote is a combinational circuit: no registers are inserted (you describe explicitly where Clash will insert registers, as we will later see).
We usually refer to circuits as <em>functions</em>, similar to programming languages such as C, Python, or Haskell.
In this case, the function we just defined is called <code>ma</code>.
Its first argument is <code>acc</code>, its second is <code>(x, y)</code> - a composite type called a tuple.
This component is "unpacked", and its first element is called <code>x</code>, its second <code>y</code>.
Everything to the right of the equals symbol is <code>ma</code>'s result.
If you followed the instructions of running the interpreter side-by-side, you can already test this function:</p>
<pre><code class="language-haskell">&gt;&gt;&gt; ma 4 (8, 9)
76
&gt;&gt;&gt; ma 2 (3, 4)
14
</code></pre>
<p>We can also examine the inferred type of <code>ma</code> in the interpreter:</p>
<pre><code class="language-haskell">&gt;&gt;&gt; :t ma
ma :: Num a =&gt; a -&gt; (a, a) -&gt; a
</code></pre>
<p>You should read this as follows:</p>
<ul>
<li>
<p><strong><code>ma ::</code></strong>, <code>ma</code> is of type…</p>
</li>
<li>
<p><strong><code>Num a</code></strong>, there is some type called <code>a</code> that is a <code>Num</code>.
Examples of instances of <code>Num</code> are <code>Int</code>, <code>Signed 16</code>, <code>Index 32</code>, or <code>Float</code>.</p>
</li>
<li>
<p><strong><code>a</code></strong>, <code>ma</code>'s first argument is of type <code>a</code></p>
</li>
<li>
<p><strong><code>(a, a)</code></strong>, <code>ma</code>'s second argument is of type <code>(a, a)</code></p>
</li>
<li>
<p><strong><code>a</code></strong>, <code>ma</code>'s result is of type <code>a</code></p>
</li>
</ul>
<p>Note that <code>ma</code> therefore works on multiple types!
The only condition we imposed is that <code>a</code> should be a <code>Num</code>ber type.
In Clash this means it should support the operations <code>Prelude.+</code>, <code>Prelude.-</code>, <code>Prelude.*</code>, and some others.
Indeed, this is why Clash adds the constraint in the first place: the definition of <code>ma</code> uses <code>+</code> and <code>*</code>.
Whenever a function works over multiple types, we call it <em>polymorphic</em> ("poly" meaning "many", "morphic" meaning "forms").
While powerful, it is not clear how Clash should synthesize this as numbers come in a great variety of (bit)sizes.
We will later see how to use this function in a <em>monomorphic</em> manner.</p>
<p>Talking about <em>types</em> also brings us to one of the most important parts of this tutorial: <em>types</em> and <em>synchronous sequential logic</em>.
Especially how we can always determine, through the types of a specification, if it describes combinational logic or (synchronous) sequential logic.
We do this by examining the definition of one of the sequential primitives, the <code>register</code> function:</p>
<pre><code class="language-haskell">register ::
  ( HiddenClockResetEnable dom
  , NFDataX a
  ) =&gt;
  a -&gt;
  Signal dom a -&gt;
  Signal dom a
register i s = ...
</code></pre>
<p>Where we see that the second argument and the result are not just of the <em>polymorphic</em> <code>a</code> type, but of the type: <code>Signal dom a</code>.
All (synchronous) sequential circuits work on values of type <code>Signal dom a</code>.
Combinational circuits always work on values of, well, not of type <code>Signal dom a</code>.
A <code>Signal</code> is an (infinite) list of samples, where the samples correspond to the values of the <code>Signal</code> at discrete, consecutive ticks of the <em>clock</em>.
All (sequential) components in the circuit are synchronized to this global <em>clock</em>.
For the rest of this tutorial, and probably at any moment where you will be working with Clash, you should probably not actively think about <code>Signal</code>s as infinite lists of samples, but just as values that are manipulated by sequential circuits.
To make this even easier, it is actually not possible to manipulate the underlying representation directly: you can only modify <code>Signal</code> values through a set of primitives such as the <code>register</code> function above.</p>
<p>Now, let us get back to the functionality of the <code>register</code> function: it is a simple <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a> that only changes state at the tick of the global <em>clock</em>, and it has an initial value <code>a</code> which is its output at time 0.
We can further examine the <code>register</code> function by taking a look at the first 4 samples of the <code>register</code> functions applied to a constant signal with the value 8:</p>
<pre><code class="language-haskell">&gt;&gt;&gt; sampleN @System 4 (register 0 (pure (8 :: Signed 8)))
[0,0,8,8]
</code></pre>
<p>Where we see that the initial value of the signal is the specified 0 value, followed by 8's.
You might be surprised to see <em>two</em> zeros instead of just a single zero.
What happens is that in Clash you get to see the output of the circuit <em>before</em> the clock becomes active.
In other words, in Clash you get to describe the powerup values of registers too.
Whether this is a defined or unknown value depends on your hardware target, and can be configured by using a different synthesis <code>Domain</code>.
The default synthesis domain, <code>@System</code>, assumes that registers do have a powerup value - as is true for most FPGA platforms in most contexts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequential-circuit"><a class="header" href="#sequential-circuit">Sequential circuit</a></h1>
<p>The <code>register</code> function is our primary sequential building block to capture <em>state</em>.
It is used internally by one of the <code>Clash.Prelude</code> functions that we will use to describe our MAC circuit.</p>
<p>A principled way to describe a sequential circuit is to use one of the classic machine models.
Within the Clash prelude library we offer a standard function to support the <a href="http://en.wikipedia.org/wiki/Mealy_machine">Mealy machine</a>.
To improve sharing, we will combine the transition function and output function into one.
This gives rise to the following Mealy specification of the MAC circuit:</p>
<pre><code class="language-haskell">macT acc (x, y) = (acc', o)
 where
  acc' = ma acc (x, y)
  o = acc
</code></pre>
<p>Note that the <code>where</code> clause and explicit tuple are just for demonstrative purposes, without loss of sharing we could have also written:</p>
<pre><code class="language-haskell">macT acc inp = (ma acc inp, acc)
</code></pre>
<p>Going back to the original specification we note the following:</p>
<ul>
<li><code>acc</code> is the current <em>state</em> of the circuit.</li>
<li><code>(x, y)</code> is its input.</li>
<li><code>acc'</code> is the updated, or next, <em>state</em>.</li>
<li><code>o</code> is the output.</li>
</ul>
<p>When we examine the type of <code>macT</code> we see that is still completely combinational:</p>
<pre><code class="language-haskell">&gt;&gt;&gt; :t macT
macT :: Num a =&gt; a -&gt; (a, a) -&gt; (a, a)
</code></pre>
<p>The <code>Clash.Prelude</code> library contains a function that creates a sequential circuit from a combinational circuit that has the same Mealy machine type/shape of <code>macT</code>:</p>
<pre><code class="language-haskell">mealy ::
  (HiddenClockResetEnable dom, NFDataX s) =&gt;
  (s -&gt; i -&gt; (s, o)) -&gt;
  s -&gt;
  (Signal dom i -&gt; Signal dom o)
mealy f initS = ...
</code></pre>
<p>The complete sequential MAC circuit can now be specified as:</p>
<pre><code class="language-haskell">mac inp = mealy macT 0 inp
</code></pre>
<p>Where the first argument of <code>mealy</code> is our <code>macT</code> function, and the second argument is the initial state, in this case 0.
We can see it is functioning correctly in our interpreter:</p>
<pre><code class="language-haskell">&gt;&gt;&gt; simulateN @System 4 mac [(1,1),(2,2),(3,3),(4,4)]
[0,1,5,14]
</code></pre>
<p>Where we simulate our sequential circuit over a list of input samples and take the first 4 output samples.
We have now completed our first sequential circuit and have made an initial confirmation that it is working as expected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-vhdl"><a class="header" href="#generating-vhdl">Generating VHDL</a></h1>
<p>We are now almost at the point that we can create actual hardware, in the form of a <a href="http://en.wikipedia.org/wiki/VHDL">VHDL</a> netlist, from our sequential circuit specification.
The first thing we have to do is create a function called <code>topEntity</code> and ensure that it has a <strong>monomorphic</strong> type.
In our case that means that we have to give it an explicit type annotation.
It might not always be needed, you can always check the type with the <code>:t</code> command and see if the function is monomorphic:</p>
<pre><code class="language-haskell">topEntity ::
  Clock System -&gt;
  Reset System -&gt;
  Enable System -&gt;
  Signal System (Signed 9, Signed 9) -&gt;
  Signal System (Signed 9)
topEntity = exposeClockResetEnable mac
</code></pre>
<p>Which makes our circuit work on 9-bit signed integers.
Including the above definition, our complete <code>MAC.hs</code> should now have the following content:</p>
<pre><code class="language-haskell">module MAC where

import Clash.Prelude

ma acc (x, y) = acc + x * y

macT acc (x, y) = (acc', o)
 where
  acc' = ma acc (x, y)
  o = acc

mac xy = mealy macT 0 xy

topEntity ::
  Clock System -&gt;
  Reset System -&gt;
  Enable System -&gt;
  Signal System (Signed 9, Signed 9) -&gt;
  Signal System (Signed 9)
topEntity = exposeClockResetEnable mac
</code></pre>
<p>The <code>topEntity</code> function is the starting point for the Clash compiler to transform your circuit description into a VHDL netlist.
It must meet the following restrictions in order for the Clash compiler to work:</p>
<ul>
<li>It must be completely monomorphic</li>
<li>It must be completely first-order</li>
<li>Although not strictly necessary, it is recommended to <em>expose</em> <code>Hidden</code> clock and reset arguments, as it makes user-controlled name assignment in the generated HDL easier to do.</li>
</ul>
<p>Our <code>topEntity</code> meets those restrictions, and so we can convert it successfully to VHDL by executing the <code>:vhdl</code> command in the interpreter.
This will create a directory called <code>vhdl</code>, which contains a directory called <code>MAC.topEntity</code>, which ultimately contains all the generated VHDL files.
You can now load these files into your favorite VHDL synthesis tool, marking <code>topEntity.vhdl</code> as the file containing the top level entity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit-test-bench"><a class="header" href="#circuit-test-bench">Circuit test bench</a></h1>
<p>There are multiple reasons as to why you might want to create a so-called <em>test bench</em> for the generated HDL:</p>
<ul>
<li>You want to compare post-synthesis / post-place&amp;route behavior to that of the behavior of the original generated HDL.</li>
<li>You need representative stimuli for your dynamic power calculations.</li>
<li>You want to verify that the HDL output of the Clash compiler has the same behavior as the Haskell/Clash specification.</li>
</ul>
<p>For these purposes, you can have the Clash compiler generate a <em>test bench</em>.
In order for the Clash compiler to do this you need to do one of the following:</p>
<ul>
<li>Create a function called <code>testBench</code> in the root module.</li>
<li>Annotate your test bench function with a <code>TestBench</code> annotation.</li>
</ul>
<p>For example, you can test the earlier defined <em>topEntity</em> by:</p>
<pre><code class="language-haskell">import Clash.Explicit.Testbench

topEntity ::
  Clock System -&gt;
  Reset System -&gt;
  Enable System -&gt;
  Signal System (Signed 9, Signed 9) -&gt;
  Signal System (Signed 9)
topEntity = exposeClockResetEnable mac

testBench :: Signal System Bool
testBench = done
 where
  testInput =
    stimuliGenerator
      clk
      rst
      $(listToVecTH [(1, 1) :: (Signed 9, Signed 9), (2, 2), (3, 3), (4, 4)])
  out = topEntity clk rst en testInput
  expected = $(listToVecTH [0 :: Signed 9, 1, 5, 14, 14, 14, 14])
  done = outputVerifier' clk rst expected out
  clk = tbSystemClockGen (not &lt;$&gt; done)
  rst = systemResetGen
  en = enableGen
</code></pre>
<p>This will create a stimulus generator that creates the same inputs as we used earlier for the simulation of the circuit, and creates an output verifier that compares against the results we got from our earlier simulation.
We can even simulate the behavior of the <em>testBench</em>:</p>
<pre><code class="language-haskell">&gt;&gt;&gt; sampleN 8 testBench
[False,False,False,False,False
cycle(&lt;Clock: System&gt;): 5, outputVerifier
expected value: 14, not equal to actual value: 30
,False
cycle(&lt;Clock: System&gt;): 6, outputVerifier
expected value: 14, not equal to actual value: 46
,False
cycle(&lt;Clock: System&gt;): 7, outputVerifier
expected value: 14, not equal to actual value: 62
,False]
</code></pre>
<p>We can see that for the first 4 samples, everything is working as expected, after which warnings are being reported.
The reason is that <code>stimuliGenerator</code> will keep on producing the last sample, (4,4), while the <code>outputVerifier'</code> will keep on expecting the last sample, 14.
In the VHDL test bench these errors will not show, as the global clock will be stopped after 4 ticks.</p>
<p>You should now again run <code>:vhdl</code> in the interpreter; this time the compiler will take a bit longer to generate all the circuits.
Inside the <code>./vhdl/MAC.testBench</code> directory you will now find all the <code>vhdl</code> files for the <em>test bench</em>.</p>
<p>After compilation is finished you load all the files in your favorite VHDL simulation tool.
Once all files are loaded into the VHDL simulator, run the simulation on the <code>testBench</code> entity.
On questasim / modelsim: doing a <code>run -all</code> will finish once the output verifier will assert its output to <code>true</code>.
The generated test bench, modulo the clock signal generator(s), is completely synthesizable.
This means that if you want to test your circuit on an FPGA, you will only have to replace the clock signal generator(s) by actual clock sources, such as an onboard PLL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-verilog-and-systemverilog"><a class="header" href="#generating-verilog-and-systemverilog">Generating Verilog and SystemVerilog</a></h1>
<p>Aside from being able to generate VHDL, the Clash compiler can also generate Verilog and SystemVerilog.
You can repeat the previous two parts of the tutorial, but instead of executing the <code>:vhdl</code> command, you execute the <code>:verilog</code> or <code>:sytemverilog</code> command in the interpreter.
This will create a directory called <code>verilog</code>, respectively <code>systemverilog</code>, which contains a directory called <code>MAC.topEntity</code>, which ultimately contains all the generated Verilog and SystemVerilog files.
Verilog files end in the file extension <code>.v</code>, while SystemVerilog files end in the file extension <code>.sv</code>.</p>
<p>This concludes the tutorial for "Your first circuit".</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
